* Flow

#+begin_src ipython
import numpy as np
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter
from scipy.spatial import cKDTree

def create_mesh(x, y, size=100, sigma=0, interp_method='nearest', mask_radius=10):
    """
    x, y: arrays of shape (n_traj, n_points)
    size: grid size along each axis
    sigma: Gaussian smoothing for velocities (0=none)
    interp_method: 'linear', 'cubic', or 'nearest'
    mask_radius: mask out grid points farther than this multiple of median point spacing

    Returns: xi, yi, ui, vi (masked arrays)
    """
    x = np.asarray(x)
    y = np.asarray(y)

    # Flatten for easier handling
    x_flat = x.flatten()
    y_flat = y.flatten()

    # Compute dense grid
    x_min, x_max = np.min(x_flat)-1, np.max(x_flat)+1
    y_min, y_max = np.min(y_flat)-1, np.max(y_flat)+1

    xi, yi = np.meshgrid(np.linspace(x_min, x_max, size),
                         np.linspace(y_min, y_max, size))

    z_min = -10 # np.min((x_min, y_min))
    z_max = 10 # np.min((x_max, y_max))

    xi, yi = np.meshgrid(np.linspace(z_min, z_max, size),
                         np.linspace(z_min, z_max, size))

    # Compute velocities (finite differences along time axis)
    dx = np.gradient(x, axis=1)
    dy = np.gradient(y, axis=1)

    # Optional smoothing of velocities
    if sigma > 0:
        dx = gaussian_filter(dx, sigma=sigma)
        dy = gaussian_filter(dy, sigma=sigma)

    dx_flat = dx.flatten()
    dy_flat = dy.flatten()

    # Prepare for griddata interpolation
    points = np.vstack((x_flat, y_flat)).T

    # Interpolate velocity components onto grid
    ui = griddata(points, dx_flat, (xi, yi), method=interp_method, fill_value=np.nan)
    vi = griddata(points, dy_flat, (xi, yi), method=interp_method, fill_value=np.nan)

    # Find where it failed
    mask = np.isnan(ui)

    # Interpolate only those points with 'nearest'
    if np.any(mask):
        ui_nearest = griddata(points, dx_flat, (xi, yi), method='nearest')
        vi_nearest = griddata(points, dy_flat, (xi, yi), method='nearest')
        ui[mask] = ui_nearest[mask]
        vi[mask] = vi_nearest[mask]

    return xi, yi, ui, vi
#+end_src

#+RESULTS:

#+begin_src ipython
import matplotlib as mpl

def plot_field(overlaps, ax, density=0.5, size=10, IF_CBAR=0):
    x = uniform_filter1d(overlaps[:, 0, :], size)
    y = uniform_filter1d(overlaps[:, 1, :], size)

    xi, yi, ui, vi = create_mesh(x, y, size=200)
    speed = np.sqrt(ui**2+vi**2)
    # speed = (speed - np.mean(speed)) / (np.std(speed) + 1e-6)

    vmin, vmax = np.nanpercentile(speed, [5, 95])
    norm = mpl.colors.Normalize(vmin, vmax)

    heatmap = ax.streamplot(xi, yi, ui, vi, density=density, arrowsize=1.5, norm=norm, color='k')
    # quiver = ax.quiver(xi, yi, ui, vi, color='k')
    # heatmap = ax.pcolormesh(xi, yi, speed, cmap='coolwarm', shading='gouraud', norm=norm)

    # ax.set_yticks([-10, 0, 10])
    # heatmap.set_clim(-1.5, 1.5)

    if IF_CBAR:
        cbar = plt.colorbar(heatmap, ax=ax)
        cbar.set_label('Norm. Speed')
        # cbar.set_clim(-1.5, 1.5)

    ax.set_xlabel('A/B Overlap')
    ax.set_ylabel('Choice Overlap')
#+end_src

#+RESULTS:

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(2*width, width))

pair = ['AC', 'AD', 'BD', 'BC']
task = 'DPA'

X_trials = X[(y.tasks==task)]
X_trials = X_trials[..., options['bins_DELAY']]

plot_field(X_trials, ax=ax[0], density=0.7, size=30)
#+end_src

#+RESULTS:
[[file:./figures/overlaps/figure_40.png]]



#+begin_src ipython

#+end_src

#+RESULTS:
