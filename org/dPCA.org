#+STARTUP: fold
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session dpca :kernel dual_data :exports results :output-dir ./figures/dpca :file (lc/org-babel-tangle-figure-filename)

* Notebook Settings

#+begin_src ipython
%load_ext autoreload
%autoreload 2
%reload_ext autoreload

%run /home/leon/dual_task/dual_data/notebooks/setup.py
%matplotlib inline
%config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/dual_data/bin/python

* Imports

#+begin_src ipython
  from sklearn.exceptions import ConvergenceWarning
  warnings.filterwarnings("ignore")

  import sys
  sys.path.insert(0, '/home/leon/dual_task/dual_data/')

  import os
  if not sys.warnoptions:
    warnings.simplefilter("ignore")
    os.environ["PYTHONWARNINGS"] = "ignore"

  import pickle as pkl
  import numpy as np
  import matplotlib.pyplot as plt
  from time import perf_counter

  from src.common.options import set_options
  from src.stats.bootstrap import my_boots_ci
  from src.decode.bump import decode_bump, circcvl
  from src.common.get_data import get_X_y_days, get_X_y_S1_S2
  from src.preprocess.helpers import avg_epochs
#+end_src

#+RESULTS:

#+begin_src ipython
from src.dPCA import dPCA
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.impute import SimpleImputer
import numpy as np

class CustomImputer(BaseEstimator, TransformerMixin):
    """
    A custom imputer for 5D data that flattens the last dimension(s) to apply
    scikit‐learn's SimpleImputer, then reshapes back to the original 5D form.
    """
    def __init__(self, strategy="mean"):
        """
        Parameters
        ----------
        strategy : str, optional (default="mean")
            The imputation strategy to pass to SimpleImputer.
            Could be "mean", "median", "most_frequent", or "constant".
        """
        self.strategy = strategy
        self.imputer_ = None
        self.original_shape_ = None

    def fit_transform(self, X, y=None):
        self.fit(X, y)
        return self.transform(X)

    def fit(self, X, y=None):
        """
        Fit the imputer to X.

        Parameters
        ----------
        X : ndarray of shape (n1, n2, n3, n4, n5)
            The 5D data to fit.

        Returns
        -------
        self : Custom5DImputer
        """
        self.original_shape_ = X.shape

        # (n1, n2, n3, n4, n5) → reshape to 2D for SimpleImputer
        # One common approach is to treat everything as features except the first axis:
        # e.g. (n1, n2*n3*n4*n5). Or flatten sections differently if needed.
        X_2d = X.reshape(X.shape[0], -1)

        # Create and fit an actual SimpleImputer
        self.imputer_ = SimpleImputer(strategy=self.strategy)
        self.imputer_.fit(X_2d)

        return self

    def transform(self, X):
        """
        Transform (impute) X with the fitted imputer.

        Parameters
        ----------
        X : ndarray of shape (n1, n2, n3, n4, n5)
            The 5D data to transform/impute.

        Returns
        -------
        X_imputed : ndarray of shape (n1, n2, n3, n4, n5)
            The imputed 5D data.
        """
        # Check shape consistency
        if X.shape != self.original_shape_:
            raise ValueError(
                f"Shape of X {X.shape} does not match the fitted shape {self.original_shape_}."
            )

        # Reshape to 2D
        X_2d = X.reshape(X.shape[0], -1)

        # Transform
        X_2d_imputed = self.imputer_.transform(X_2d)

        # Reshape back to 5D
        X_imputed = X_2d_imputed.reshape(self.original_shape_)

        return X_imputed
#+end_src

#+RESULTS:

** Other


#+begin_src ipython
class standard_scaler():
      def __init__(self, axis=0):
            self.axis = axis

      def fit(self, X):
            self.mean = np.nanmean(X, axis=axis, keepdims=True)
            self.std = np.nanstd(X, axis=axis, keepdims=True) + 1e-6

            return self

      def transform(self, X):
            return (X - self.mean) / self.std

      def fit_transform(self, X):
            self.fit(X)
            return self.transform(X)
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  from scipy.stats import bootstrap

  def get_bootstrap_ci(data, statistic=np.mean, confidence_level=0.95, n_resamples=1000, random_state=None):
      result = bootstrap((data,), statistic)
      ci_lower, ci_upper = result.confidence_interval

#+RESULTS:

#+RESULTS:

      return np.array([ci_lower, ci_upper])
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython
def angle_AB(A, B):
      A_norm = A / (np.linalg.norm(A) + 1e-5)
      B_norm = B / (np.linalg.norm(B) + 1e-5)

      cos_theta = A_norm @ B_norm.T
      angle_radians = np.arccos(np.clip(cos_theta, -1.0, 1.0))

      return np.degrees(angle_radians)
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  import pickle as pkl

  def pkl_save(obj, name, path="."):
      pkl.dump(obj, open(path + "/" + name + ".pkl", "wb"))


  def pkl_load(name, path="."):
      return pkl.load(open(path + "/" + name + '.pkl', "rb"))

#+end_src

#+RESULTS:

** Plots

#+begin_src ipython
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          # for i in range(b.shape[0]):
          v = b - (b @ a) * a / (a @ a)

      if IF_NORM:
          u = u / (np.linalg.norm(u) + 1e-6)
          v = v / (np.linalg.norm(v) + 1e-6)

          # return np.arccos(np.clip(u @ v, -1.0, 1.0))

      return np.arctan2(v, u) % (2.0 * np.pi)
#+end_src

#+RESULTS:

* Parameters

#+begin_src ipython
  DEVICE = 'cuda:0'
  #  mice = ['ChRM04','JawsM15', 'JawsM18', 'ACCM03', 'ACCM04']
  mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18', 'ChRM04', 'ChRM23', 'ACCM03', 'ACCM04']
  tasks = ['DPA', 'DualGo', 'DualNoGo']
  # mice = ['AP02', 'AP12']
  # mice = ['PP09', 'PP17']

  kwargs = {
      'mouse': mice[1], 'laser': 0,
      'trials': '', 'reload': 0, 'data_type': 'dF',
      'prescreen': None, 'pval': 0.05, 'n_comp': 0,
      'preprocess': False, 'scaler_BL': 'robust',
      'avg_noise': True, 'unit_var_BL': True,
      'random_state': None, 'T_WINDOW': 0.0,
      'l1_ratio': 0.95,
      'n_comp': None, 'scaler': None,
      'bootstrap': 1, 'n_boots': 1000,
      'n_splits': 3, 'n_repeats': 10,
      'class_weight': 0,
      'multilabel':0,
      'mne_estimator': 'generalizing', # sliding or generalizing
      'n_jobs': 128,
      'bolasso_penalty': 'l2',
      'bolasso_pval': 0.05,
      'laser' : -1,
  }

  # kwargs['days'] = ['first', 'middle', 'last']
  kwargs['days'] = ['first', 'last']
  # kwargs['days'] = 'all'
  # kwargs['days'] = ['first']

  options = set_options(**kwargs)
  print(options['days'])
  options['mice'] = mice
  name = '5folds'
#+end_src

#+RESULTS:
: ['first', 'last']

#+begin_src ipython
import pandas as pd
options['mice'] = ['JawsM15']

new_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'ChRM23']

options['reload'] = 0
X_mouse, y_mouse = [], []
y_laser = []
y_choice = []
y_dfs = []

for idx, mouse in enumerate(options['mice']):
    options['mouse'] = mouse
    options['features'] = 'sample'
    options['verbose'] = 0

    options['trials'] = ''
    options['reload'] = 0

    if mouse in new_mice:
        options['NEW_DATA'] = 1
    else:
        options['NEW_DATA'] = 0

    options = set_options(**options)

    X_list = []
    # y_list = []
    # y_list2 = []
    # y_list3 = []
    y_df__ = []
    tasks = ["DPA", "DualGo", "DualNoGo"]

    for i, day in enumerate(options['days']):
        X_dum = []
        # y_dum = []
        # y_dum2 = []
        # y_dum3 = []
        y_df_ = []

        options['day'] = day

        for task in tasks:
            options['task'] = task
            X_days, y_days = get_X_y_days(**options)
            options['reload'] = 0
            X_data, y_data = get_X_y_S1_S2(X_days, y_days, **options)

            X_dum.append(X_data)
            y_df_.append(y_data)

            # y_dum.append(y_data.sample_odor)
            # y_dum.append(y_data.odor_pair)
            # y_dum2.append(y_data.laser)
            # y_dum3.append(y_data.choice)

        y_df_ = pd.concat(y_df_)
        y_df_['DAY'] = day
        y_df__.append(y_df_)

        X_list.append(X_dum)

        # y_list.append(y_dum)
        # y_list2.append(y_dum2)
        # y_list3.append(y_dum3)

    X_mouse.append(X_list)
    y_df__ = pd.concat(y_df__)
    y_df__['mouse'] = mouse
    y_dfs.append(y_df__)

    # y_mouse.append(y_list)
    # y_laser.append(y_list2)
    # y_choice.append(y_list3)

y_dfs = pd.concat(y_dfs)
#+end_src

#+RESULTS:

#+begin_src ipython
#print(np.array(X_mouse[0]).shape, y_dfs.shape)
#+end_src

#+RESULTS:

* dPCA
** Stimuli choice time
*** reshape

#+begin_src ipython
from sklearn.model_selection import KFold, LeaveOneOut, StratifiedKFold, RepeatedKFold
from sklearn.preprocessing import MinMaxScaler, RobustScaler, StandardScaler

def crossval_dpca(X_stim, Z, dpca, folds, IF_SCALE=0):

    Dp_cv = []
    Ds_cv = []

    Zp_cv =  []
    Zs_cv =  []
    Zps_cv =  []

    scaler = StandardScaler()

    # remove nans from cv
    axes = tuple(range(1, X_stim.ndim))
    mask = np.any(np.isnan(X_stim), axis=axes)
    X = X_stim[~mask]

    # Iterate over each fold
    for train_index, test_index in folds.split(X):

            X_train, X_test = X[train_index], X[test_index]

            if IF_SCALE:
                X_train = np.swapaxes(X_train, 0, 1)
                train_size = X_train.shape
                X_train = X_train.reshape((X_train.shape[0], -1)).T
                X_train = scaler.fit_transform(X_train).T.reshape(train_size)
                X_train = np.swapaxes(X_train, 0, 1)

                X_test = np.swapaxes(X_test, 0, 1)
                test_size = X_test.shape
                X_test = X_test.reshape((X_test.shape[0], -1)).T
                X_test = scaler.transform(X_test).T.reshape(test_size)
                X_test = np.swapaxes(X_test, 0, 1)

            X_avg = np.nanmean(X_train, 0)
            axes2 = tuple(range(1, X_avg.ndim))
            X_avg -= np.nanmean(X_avg, axis=axes2, keepdims=True) # subtract mean across neurons
            dpca.fit(X_avg, X_train)

            Dp_cv.append(dpca.D['p'])
            Ds_cv.append(dpca.D['s'])

            X_avg = np.nanmean(X_test, 0)
            axes2 = tuple(range(1, X_avg.ndim))
            X_avg -= np.nanmean(X_avg, axis=axes2, keepdims=True) # subtract mean across neurons
            X_test_pca = dpca.transform(X_avg)

            # Store the projected test samples
            Zp_cv.append(X_test_pca['p'])
            Zs_cv.append(X_test_pca['s'])
            Zps_cv.append(X_test_pca['ps'])

    dpca.D['p'] = np.nanmean(Dp_cv, axis=0)
    dpca.D['s'] = np.nanmean(Ds_cv, axis=0)

    Z['p'] = np.nanmean(Zp_cv, axis=0)
    Z['s'] = np.nanmean(Zs_cv, axis=0)
    Z['ps'] = np.nanmean(Zps_cv, axis=0)

    return Z, dpca
#+end_src

#+RESULTS:

#+begin_src ipython
def reshape_X(X, y, size=32):
    tasks = ['DPA', 'DualGo', 'DualNoGo']
    X_stim = np.zeros((3, 2, 2, size*3, X.shape[-2], 84)) * np.nan

    for i in range(3):
        idx = (y.tasks == tasks[i]) & (y.laser == 0)

        X0 = X[idx]
        y0 = y[idx]

        for j in range(2):
            for k in range(2):
                dum = X0[(y0.sample_odor==j) & (y0.choice==k)]
                X_stim[i, j, k, :dum.shape[0]] = dum

    X_stim = np.swapaxes(X_stim, 1, 2)
    X_stim = np.swapaxes(X_stim, 1, 3)

    print('X_stim', X_stim.shape)
    # all conditions
    X_all_cond = np.vstack(X_stim.copy())
    X_all_cond = np.swapaxes(X_all_cond, 1, 3)

    # condition as a marginalization
    # X_cond = np.swapaxes(X_stim, 2, 4)
    X_cond = np.swapaxes(X_stim, 0, 1)
    X_cond = np.swapaxes(X_cond, 1, 4)
    X_cond = np.swapaxes(X_cond, 2, 3)

    print(X_all_cond.shape, X_cond.shape)

    return X_all_cond, X_cond
#+end_src

#+RESULTS:

#+begin_src ipython
# crossvalidate the regularization parameter
def crossval_dpca_reg(X_trials, marginalization='st', lambdas=np.logspace(-3, 3, 10)):
    """ Crossvalidates (5-fold) the lambda for the PCA model. Better than built-in function as built-in does not crossvalidate.
    Inputs:         X_trials:           trial-by-trial input vector (trials, neurons, stimuli, times)
                    marginalization:    marginalization points
                    lambdas:            range of potential lambdas to test for

    Outputs:        best_lambda:    Best crossvalidated lambda parameter
                    all_scores:     dictionary of all lambdas with their respective crossvalidation scores
    """
    kf = KFold(n_splits=5, shuffle=True, random_state=None)

    axes = tuple(range(1, X_trials.ndim))
    mask = np.any(np.isnan(X_trials), axis=axes)
    X = X_trials[~mask]


    best_lambda = None
    best_score = -np.inf
    all_scores = {}
    for lam in lambdas:
        scores = []
        for train_idx, test_idx in kf.split(X):
            # Average over training trials
            X_train_avg = np.nanmean(X[train_idx], axis=0)

            axes = tuple(range(1, X_train_avg.ndim))
            X_train_avg -= np.nanmean(X_train_avg, axis=axes, keepdims=True) # subtract mean across neurons

            # Average over testing trials
            X_test = X[test_idx]  # keep trials separate
            X_test_avg = np.nanmean(X_test, axis=0)
            X_test_avg -= np.nanmean(X_test_avg, axis=axes, keepdims=True)

            # Fit dPCA on training average
            dpca = dPCA.dPCA(labels=marginalization, regularizer=lam)
            dpca.protect = ['t']
            Z = dpca.fit_transform(X_train_avg, X[train_idx])

            # Compute reconstruction trial-averages from components of training data
            X_recons = []
            for marg in Z:
                X_marg = dpca.inverse_transform(Z[marg], marg)
                X_recons.append(X_marg)
            X_reconstructed = np.sum(X_recons, axis=0)

            # Evaluate reconstruction of the test average
            mse = np.mean((X_test_avg - X_reconstructed) ** 2)
            total_var = np.mean(X_test_avg ** 2)
            explained_ratio = 1 - mse / total_var
            scores.append(explained_ratio)

        # average out crossvalidations
        mean_score = np.mean(scores)
        all_scores[lam] = mean_score
        if mean_score > best_score:
            best_score = mean_score
            best_lambda = lam

    return best_lambda
#+end_src

#+RESULTS:

#+begin_src ipython
Z_mouse = []
dpca_mouse = []

imputer = CustomImputer()

for idx_mouse, mouse in enumerate(options['mice']):
    Z_days = []
    dpca_days = []

    options['mouse'] = mouse
    options = set_options(**options)
    print(mouse)

    for i, day in enumerate(options['days']):
        X = np.array(X_mouse[idx_mouse][i])
        X = X.reshape((-1, X.shape[-2], X.shape[-1]))

        y = y_dfs[(y_dfs.mouse==mouse) & (y_dfs.DAY == day)]

        X_stim, X_cond = reshape_X(X, y)
        # X_stim = imputer.fit_transform(X_stim)
        X_avg = np.nanmean(X_cond, 0)

        print('X_stim', X_stim.shape, 'X_cond', X_cond.shape, 'X_avg', X_avg.shape)

        reg = crossval_dpca_reg(X_cond, marginalization='psct', lambdas=np.logspace(-3, 3, 10))

        dpca = dPCA.dPCA(labels='psct', n_components=1, regularizer=reg)
        dpca.protect = ['t']

        axes = tuple(range(1, X_avg.ndim))
        X_avg -= np.nanmean(X_avg, axis=axes, keepdims=True) # subtract mean across neurons

        Z = dpca.fit_transform(X_avg, X_cond)

        # Z = []
        # for i in range(3):
        #     Zi = dpca.transform(np.nanmean(X_cond[i], 0))
        #     Z.append(Zi)

        # folds = KFold(n_splits=5)
        folds = RepeatedKFold(n_splits=5, n_repeats=10)
        # folds = LeaveOneOut() # too long

        Z, dpca = crossval_dpca(X_cond, Z, dpca, folds, IF_SCALE=0)

        Z_days.append(Z)
        dpca_days.append(dpca)

    Z_mouse.append(Z_days)
    dpca_mouse.append(dpca_days)
#+end_src

#+RESULTS:
: JawsM15
: X_stim (3, 96, 2, 2, 693, 84)
: (288, 693, 2, 2, 84) (96, 693, 2, 2, 3, 84)
: X_stim (288, 693, 2, 2, 84) X_cond (96, 693, 2, 2, 3, 84) X_avg (693, 2, 2, 3, 84)
: X_stim (3, 96, 2, 2, 693, 84)
: (288, 693, 2, 2, 84) (96, 693, 2, 2, 3, 84)
: X_stim (288, 693, 2, 2, 84) X_cond (96, 693, 2, 2, 3, 84) X_avg (693, 2, 2, 3, 84)

#+begin_src ipython
Z_mouse = np.array(Z_mouse)
dpca_mouse = np.array(dpca_mouse)
print(Z_mouse.shape, dpca_mouse.shape)
#+end_src

#+RESULTS:
: (1, 2) (1, 2)

#+begin_src ipython
pkl_save(Z_mouse, 'Z_mouse_%s' % name, path="/storage/leon/dual_task/data/mice/dPCA")
pkl_save(dpca_mouse, 'dPCA_mouse_%s' % name, path="/storage/leon/dual_task/data/mice/dPCA")
#+end_src

#+RESULTS:

*** plots

#+begin_src ipython
idx_mouse = 0
print(options['mice'][idx_mouse])
Z = Z_mouse[idx_mouse]
print(Z.shape)
dpca = dpca_mouse[idx_mouse]
print(Z[0]['t'].shape)
task = 0
#+end_src

#+RESULTS:
: JawsM15
: (2,)
: (1, 2, 2, 3, 84)

 #+begin_src ipython
from src.common.plot_utils import add_vlines

def plot_dPCA(Z, key, ax, task=0):
    size = Z[key].shape[0]
    xtime = np.linspace(0, 14, Z[key].shape[-1])

    colors=['b', 'b', 'r', 'r']
    labels = ['AD', 'AC', 'BC', 'BD']
    ls = ['--', '-', '--', '-']

    if key=='s':
        name = 'Sample'
    if key=='p':
        name = 'Pair'
    if key=='t':
        name = 'Time'

    # fig, ax = plt.subplots(1, size, figsize=[size * width, height])
    if size==1:
        ax = [ax]

    for idx in range(2):
        for i in range(Z[key].shape[2]):
            for j in range(Z[key].shape[0]):
                ax[j].plot(xtime, Z[key][j, i, idx, task].T, ls=ls[i], color=colors[i+ 2*idx], label=labels[i])
                add_vlines(ax=ax[j])
                ax[j].set_xlabel('Time (s)')
                ax[j].set_ylabel('%s dPC %d' % (name, j+1))


            if size>1:
                ax[2].plot(Z[key][0, i, idx], Z[key][1, i, idx], ls=ls[i], label=labels[i], color=colors[i+2*idx])
                ax[2].set_xlabel('%s dPC 1' % name)
                ax[2].set_ylabel('%s dPC 2' % name)

    ax[0].legend(fontsize=10)
    # plt.show()
#+end_src

#+RESULTS:

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[3 * width, height])

plot_dPCA(Z[0], 's', ax[0] , task)
plot_dPCA(Z[0], 'p', ax[1], task)

ls = ['--', '-', '--', '-']
labels = ['AD', 'AC', 'BC', 'BD']
colors=['b', 'b', 'r', 'r']

for i in range(2):
    for idx in range(2):
        ax[2].plot(Z[0]['s'][0, i, idx, task].T, Z[0]['p'][0, i, idx, task].T, ls=ls[i], label=labels[i], color=colors[i+2*idx])
#+end_src

#+RESULTS:
[[./figures/dpca/figure_21.png]]

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[3 * width, height])

plot_dPCA(Z[1], 's', ax[0], task)
plot_dPCA(Z[1], 'p', ax[1], task)

for i in range(2):
    for idx in range(2):
        ax[2].plot(Z[1]['s'][0, i, idx, task].T, Z[1]['p'][0, i, idx, task].T, ls=ls[i], label=labels[i], color=colors[i+2*idx])
#+end_src

#+RESULTS:
[[./figures/dpca/figure_22.png]]


#+begin_src ipython

#+end_src

#+RESULTS:

*** Energy

#+begin_src ipython
def remove_close_entries_with_indices(nums, threshold, modulus):
    # Create a list of tuples (value, index)
    indexed_nums = list(enumerate(nums))

    # Sort based on the values but keep the original indices
    indexed_nums.sort(key=lambda x: x[1])

    # Function to calculate circular distance
    def circular_distance(x, y, mod):
        return min((x - y) % mod, (y - x) % mod)

    filtered_indices = []
    filtered_nums = []

    for idx, num in indexed_nums:
        if not filtered_nums:
            filtered_nums.append(num)
            filtered_indices.append(idx)
        elif all(circular_distance(num, existing_num, modulus) >= threshold for existing_num in filtered_nums):
            filtered_nums.append(num)
            filtered_indices.append(idx)

    return filtered_indices
#+end_src

#+RESULTS:

#+begin_src ipython
import numpy as np
from scipy.optimize import differential_evolution
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

def find_multiple_minima_from_values(x_vals, y_vals, num_runs=100, tol=0.1, popsize=2, maxiter=1000, min_distance=35):

    energy_function = interp1d(x_vals, y_vals, kind='cubic', fill_value="extrapolate")
    bounds = [(x_vals.min(), x_vals.max())]
    results = []

    result_old = 999
    for _ in range(num_runs):
        result = differential_evolution(energy_function, bounds, strategy='rand1bin',
                                        maxiter=maxiter, popsize=popsize, tol=tol,
                                        seed=np.random.randint(0, 10000))

        results.append((result.x[0], result.fun))

    results = np.array(results)
    indices = remove_close_entries_with_indices(results[:, 0], min_distance, 360)
    results = results[indices]

    return results
#+end_src

#+RESULTS:

#+begin_src ipython
from src.attractor.landscape import EnergyLandscape
energy = EnergyLandscape(IF_HMM=0)
#+end_src

#+RESULTS:

#+begin_src ipython
num_bins = 64
window = 10
bins = np.linspace(0, 2*np.pi, num_bins, endpoint=False)
if len(options['days'])>3:
     days = np.arange(1, 7)
else:
     days = options['days']

print(days)
#+end_src

#+RESULTS:
: ['first', 'last']

#+begin_src ipython
index = []
for dpca in dpca_mouse[idx_mouse]:
    print(dpca.D['s'].shape)
    theta = get_theta(dpca.D['s'].T[0], dpca.D['p'].T[0], IF_NORM=1, GM=1)

    index.append(np.argsort(theta, -1))
index = np.array(index)
print(index.shape)
#+end_src

#+RESULTS:
: (693, 1)
: (693, 1)
: (2, 693)

#+begin_src ipython
epoch = np.concatenate((options['bins_BL'], options['bins_STIM'], options['bins_ED']))
energy_mouse, ci_mouse = [], []

for idx, mouse in enumerate([1]):
    X_list = X_mouse[idx_mouse]

    options['mouse'] = options['mice'][idx_mouse]
    options = set_options(**options)

    energy_day = []
    ci_day = []

    for i, day in enumerate(options['days']):

        X = np.vstack(X_list[i])
        X = X [:, index[i]]
        X = X[..., options['bins_ED']]
        # X = X[..., epoch]

        # X = X_list[i][0]
        # X = X [:, index[i]]
        # X = X[..., options['bins_DELAY']]
        # X = X[..., epoch]

        # print(X.shape)
        _, phi = decode_bump(X, axis=1)

        landscape = energy.fit(phi, bins, window=window)
        energy_day.append(landscape)

        ci = None
        ci_day.append(ci)

    energy_mouse.append(energy_day)
    ci_mouse.append(ci_day)
#+end_src

#+RESULTS:

#+begin_src ipython
cmap = plt.get_cmap('Blues')
print(options['n_days'])
colors = [cmap((i+1)/ options['n_days']) for i in range(options['n_days']+1)]
#+end_src

#+RESULTS:
: 6

#+begin_src ipython
from scipy.signal import find_peaks, find_peaks_cwt

minima_mouse = np.zeros((9, len(days), 2), dtype='int') * np.nan

for idx, mouse in enumerate([1]):
    energy_day = energy_mouse[0]

    options['mouse'] = options['mice'][idx_mouse]
    options = set_options(**options)

    for i, day in enumerate(options['days']):
        locations = np.linspace(0, 360, energy_day[i].shape[0])

        # minimas = find_peaks_cwt(-energy_day[i], widths=np.arange(1, 10))
        minimas = find_multiple_minima_from_values(locations, energy_day[i])[:, 0]
        # print(minimas)

        if len(minimas)<2:
            minimas = [minimas[0], minimas[0]]

        minima_mouse[idx][i] = minimas[:2]
#+end_src

#+RESULTS:

#+begin_src ipython
y_loc = []
for idx, mouse in enumerate(options['mice']):
     id = ~np.isnan(minima_mouse[idx].T)
     minima = minima_mouse[idx].T

     # y1 = locations[minima[0][id[0]].astype('int')] * np.pi / 180.0
     # y2 = locations[minima[1][id[1]].astype('int')] * np.pi / 180.0

     y1 = minima[0][id[0]].astype('int') * np.pi / 180.0
     y2 = minima[1][id[1]].astype('int') * np.pi / 180.0

     y_mean = (np.sin(y1)+np.sin(y2)) / 2

     while len(y_mean)<len(days):
          y_mean = np.append(y_mean, np.nan)

     y_loc.append(y_mean)

y_loc = np.array(y_loc)

plt.plot(np.arange(1, len(days)+1), np.nanmean(y_loc, 0), '-o')
plt.plot(np.arange(1, len(days)+1), y_loc.T, '-', alpha=.2)

# plt.xticks(np.arange(1, 7))
plt.axhline(0, ls='--', color='k')
plt.xlabel('Day')
plt.ylabel('Y-loc (a.u.)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/dpca/figure_32.png]]

#+begin_src ipython
from scipy.signal import find_peaks
fig, ax = plt.subplots(1, 2, figsize= [2*width, 1*width * golden_ratio])
ax_flat = ax.flatten()

minima_mouse = np.zeros((9, 6, 2), dtype='int') * np.nan

for idx, mouse in enumerate([1]):
    peaks_list, minimas_list = [], []
    energy_day = energy_mouse[idx]

    # options['mouse'] = mouse
    options = set_options(**options)

    ax = ax_flat[idx]

    for i, day in enumerate(options['days']):
        locations = np.linspace(0, 360, energy_day[i].shape[0])
        ax.plot(locations, energy_day[i] * 100 , color=colors[i])
        ax.set_title(mouse)

        # peaks = find_peaks_cwt(energy_day[i], widths=np.arange(1, 10))[:2]
        # minimas = find_peaks_cwt(-energy_day[i], widths=np.arange(1, 10))[:2]

        # peaks,  _ = find_peaks(energy_day[i], width=8)[:2]
        # minimas, _ = find_peaks(-energy_day[i], width=8)[:2]

        # ax.plot(locations[peaks], energy_day[i][peaks] * 100, '^', color=colors[i])
        # ax.plot(locations[minimas], energy_day[i][minimas] * 100, 'o', color=colors[i])

        minimas = find_multiple_minima_from_values(locations, energy_day[i])
        ax.plot(minimas[:, 0], minimas[:, 1] * 100, 'o', color=colors[i])

        minima_mouse[idx][i] = minimas[:2, 0]

        # if len(peaks)<2:
        #     peaks =[peaks[0], peaks[0]]
        # if len(minimas)<2:
        #     minimas = [minimas[0], minimas[0]]

        # peaks_list.append(peaks[:1])
        # minimas_list.append(minimas[:1])

        # print(peaks, minimas)

        ax.set_xlabel('Pref Loc (°)')
        ax.set_ylabel('Energy')
        # ax.set_ylim([0, 3])
#+end_src

#+RESULTS:
[[./figures/dpca/figure_33.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Stimuli pair time
*** reshape

#+begin_src ipython
DURATION = 14
#+end_src

#+RESULTS:

#+begin_src ipython
from sklearn.model_selection import KFold, LeaveOneOut

def crossval_dpca(X_stim, Z, dpca, folds):

    Dp_cv = []
    Ds_cv = []

    Zp_cv =  []
    Zs_cv =  []
    Zps_cv =  []

    # Iterate over each fold
    for train_index, test_index in folds.split(X_stim):
        X_train, X_test = X_stim[train_index], X_stim[test_index]

        try:
            X_avg = np.nanmean(X_train, 0)
            dpca.fit(X_avg, X_train)

            Dp_cv.append(dpca.D['p'])
            Ds_cv.append(dpca.D['s'])

            X_avg = np.nanmean(X_test, 0)
            X_test_pca = dpca.transform(X_avg)

            # Store the projected test samples
            Zp_cv.append(X_test_pca['p'])
            Zs_cv.append(X_test_pca['s'])
            Zps_cv.append(X_test_pca['ps'])

        except:
            pass

    dpca.D['p'] = np.nanmean(Dp_cv, axis=0)
    dpca.D['s'] = np.nanmean(Ds_cv, axis=0)

    Z['p'] = np.nanmean(Zp_cv, axis=0)
    Z['s'] = np.nanmean(Zs_cv, axis=0)
    Z['ps'] = np.nanmean(Zps_cv, axis=0)

    return Z, dpca
#+end_src

#+RESULTS:

#+begin_src ipython
def reshape_X(X, y, y_las):
    X_stim = []
    for i in range(3):
        X0 = X[i]
        y0 = y[i]
        y_opto = y_las[i]

        X0 = X0[y_opto==0]
        y0 = y0[y_opto==0]

        X_stim.append(np.stack((X0[y0==0], X0[y0==2], X0[y0==1], X0[y0==3])))

    X_stim = np.array(X_stim)

    X_stim = np.swapaxes(X_stim, 1, 2)
    X_stim = np.vstack(X_stim)
    X_stim = np.swapaxes(X_stim, 1, 2)

    # print(X_stim.shape)
    X_stim = X_stim.reshape(-1, X_stim.shape[1], 2, 2 ,84)

    return X_stim
#+end_src

#+RESULTS:

#+begin_src ipython
Z_days = []
dpca_days = []

for i in range(len(options['days'])):
    X = np.array(X_mouse[0][i])
    y = np.array(y_mouse[0][i])
    y_las = np.array(y_laser[0][i])

    X_stim = reshape_X(X, y, y_las)
    X_avg = X_stim.mean(0)
    print('X_stim', X_stim.shape, 'X_avg', X_avg.shape)

    dpca = dPCA.dPCA(labels='pst', n_components=1, regularizer='auto', n_trials=3)
    dpca.protect = ['t']
    Z = dpca.fit_transform(X_avg, X_stim)

    folds = LeaveOneOut()
    Z, dpca = crossval_dpca(X_stim, Z, dpca, folds)

    Z_days.append(Z)
    dpca_days.append(dpca)
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: IndexError                                Traceback (most recent call last)
: Cell In[37], line 6
:       4 for i in range(len(options['days'])):
:       5     X = np.array(X_mouse[0][i])
: ----> 6     y = np.array(y_mouse[0][i])
:       7     y_las = np.array(y_laser[0][i])
:       9     X_stim = reshape_X(X, y, y_las)
:
: IndexError: list index out of range
:END:

#+begin_src ipython
A = dpca.D['s'].T[0]
B = dpca.D['p'].T[0]
print(angle_AB(A, B))
#+end_src

#+RESULTS:
: 89.31913185361141

*** plots

#+begin_src ipython
Z = Z_days[-1]
dpca = dpca_days[-1]
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: IndexError                                Traceback (most recent call last)
: Cell In[39], line 1
: ----> 1 Z = Z_days[-1]
:       2 dpca = dpca_days[-1]
:
: IndexError: list index out of range
:END:

 #+begin_src ipython
from src.common.plot_utils import add_vlines

def plot_dPCA(Z, key):
    size = Z[key].shape[0]
    xtime = np.linspace(0, 14, Z[key].shape[-1])

    colors=['b', 'b', 'r', 'r']
    labels = ['AC', 'AD', 'BD', 'BC']
    ls = ['-', '--', '-', '--']

    if key=='s':
        name = 'Sample'
    if key=='p':
        name = 'Pair'
    if key=='t':
        name = 'Time'

    fig, ax = plt.subplots(1, size, figsize=[size * width, height])
    if size==1:
        ax = [ax]

    for idx in range(2):
        for i in range(Z[key].shape[2]):
            for j in range(Z[key].shape[0]):
                ax[j].plot(xtime, Z[key][j, i, idx], ls=ls[i], color=colors[i+ 2*idx], label=labels[i])
                add_vlines(ax=ax[j])
                ax[j].set_xlabel('Time (s)')
                ax[j].set_ylabel('%s dPC %d' % (name, j+1))


            if size>1:
                ax[2].plot(Z[key][0, i, idx], Z[key][1, i, idx], ls=ls[i], label=labels[i], color=colors[i+2*idx])
                ax[2].set_xlabel('%s dPC 1' % name)
                ax[2].set_ylabel('%s dPC 2' % name)

    ax[0].legend(fontsize=10)
    plt.show()
#+end_src

#+RESULTS:

#+begin_src ipython
plot_dPCA(Z, 't')
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
Cell In[41], line 1
----> 1 plot_dPCA(Z, 't')

Cell In[40], line 4, in plot_dPCA(Z, key)
      3 def plot_dPCA(Z, key):
----> 4     size = Z[key].shape[0]
      5     xtime = np.linspace(0, 14, Z[key].shape[-1])
      7     colors=['b', 'b', 'r', 'r']

IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices
#+end_example
:END:

#+begin_src ipython
plot_dPCA(Z, 's')
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
Cell In[42], line 1
----> 1 plot_dPCA(Z, 's')

Cell In[40], line 4, in plot_dPCA(Z, key)
      3 def plot_dPCA(Z, key):
----> 4     size = Z[key].shape[0]
      5     xtime = np.linspace(0, 14, Z[key].shape[-1])
      7     colors=['b', 'b', 'r', 'r']

IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices
#+end_example
:END:

#+begin_src ipython
plot_dPCA(Z, 'p')
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
Cell In[43], line 1
----> 1 plot_dPCA(Z, 'p')

Cell In[40], line 4, in plot_dPCA(Z, key)
      3 def plot_dPCA(Z, key):
----> 4     size = Z[key].shape[0]
      5     xtime = np.linspace(0, 14, Z[key].shape[-1])
      7     colors=['b', 'b', 'r', 'r']

IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices
#+end_example
:END:

#+begin_src ipython
for i in range(2):
    for idx in range(2):
        plt.plot(Z['s'][0, i, idx], Z['p'][0, i, idx], ls=ls[i], label=labels[i], color=colors[i+2*idx])

plt.xlabel('Sample dPC 1')
plt.ylabel('Pair dPC 1')
plt.show()
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: IndexError                                Traceback (most recent call last)
: Cell In[44], line 3
:       1 for i in range(2):
:       2     for idx in range(2):
: ----> 3         plt.plot(Z['s'][0, i, idx], Z['p'][0, i, idx], ls=ls[i], label=labels[i], color=colors[i+2*idx])
:       5 plt.xlabel('Sample dPC 1')
:       6 plt.ylabel('Pair dPC 1')
:
: IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices
:END:

#+begin_src ipython

#+end_src

#+RESULTS:

*** Energy

#+begin_src ipython
def remove_close_entries_with_indices(nums, threshold, modulus):
    # Create a list of tuples (value, index)
    indexed_nums = list(enumerate(nums))

    # Sort based on the values but keep the original indices
    indexed_nums.sort(key=lambda x: x[1])

    # Function to calculate circular distance
    def circular_distance(x, y, mod):
        return min((x - y) % mod, (y - x) % mod)

    filtered_indices = []
    filtered_nums = []

    for idx, num in indexed_nums:
        if not filtered_nums:
            filtered_nums.append(num)
            filtered_indices.append(idx)
        elif all(circular_distance(num, existing_num, modulus) >= threshold for existing_num in filtered_nums):
            filtered_nums.append(num)
            filtered_indices.append(idx)

    return filtered_indices
#+end_src

#+RESULTS:

#+begin_src ipython
import numpy as np
from scipy.optimize import differential_evolution
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

def find_multiple_minima_from_values(x_vals, y_vals, num_runs=100, tol=0.1, popsize=2, maxiter=1000, min_distance=35):

    energy_function = interp1d(x_vals, y_vals, kind='cubic', fill_value="extrapolate")
    bounds = [(x_vals.min(), x_vals.max())]
    results = []

    result_old = 999
    for _ in range(num_runs):
        result = differential_evolution(energy_function, bounds, strategy='rand1bin',
                                        maxiter=maxiter, popsize=popsize, tol=tol,
                                        seed=np.random.randint(0, 10000))

        results.append((result.x[0], result.fun))

    results = np.array(results)
    indices = remove_close_entries_with_indices(results[:, 0], min_distance, 360)
    results = results[indices]

    return results
#+end_src

#+RESULTS:

#+begin_src ipython
from src.attractor.landscape import EnergyLandscape
energy = EnergyLandscape(IF_HMM=0)
#+end_src

#+RESULTS:

#+begin_src ipython
num_bins = 64
window = 10
bins = np.linspace(0, 2*np.pi, num_bins, endpoint=False)
if len(options['days'])>3:
     days = np.arange(1, 7)
else:
     days = options['days']

print(days)
#+end_src

#+RESULTS:
: ['first', 'last']

#+begin_src ipython
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          v = b - (b @ a) * a / (a @ a)

      if IF_NORM:
          u = u / np.linalg.norm(u)
          v = v / np.linalg.norm(v)

      return np.arctan2(v, u) % (2.0 * np.pi)
#+end_src

#+RESULTS:

#+begin_src ipython
index = []
for dpca in dpca_days:
    print(dpca.D['s'].shape)
    theta = get_theta(dpca.D['s'].T[0], dpca.D['p'].T[0], IF_NORM=1, GM=1)
    index.append(np.argsort(theta, -1))
index = np.array(index)
print(index.shape)
#+end_src

#+RESULTS:
: (0,)

#+begin_src ipython
epoch = np.concatenate((options['bins_STIM'], options['bins_DELAY']))
energy_mouse, ci_mouse = [], []

for idx, mouse in enumerate(options['mice']):
    X_list = X_mouse[idx]

    options['mouse'] = mouse
    options = set_options(**options)

    energy_day = []
    ci_day = []

    for i, day in enumerate(options['days']):
        X = np.vstack(X_list[i])
        X = X[..., options['bins_ED']]
        # X = X[..., epoch]
        _, phi = decode_bump(X, axis=1)

        X = X_list[i][0]
        X = X[..., options['bins_DELAY']]
        # X = X[..., epoch]
        _, phi = decode_bump(X, axis=1)

        landscape = energy.fit(phi, bins, window=window)
        energy_day.append(landscape)

        ci = None
        ci_day.append(ci)

    energy_mouse.append(energy_day)
    ci_mouse.append(ci_day)
#+end_src

#+RESULTS:

#+begin_src ipython
cmap = plt.get_cmap('Blues')
colors = [cmap((i+1)/6) for i in range(7)]
#+end_src

#+RESULTS:

#+begin_src ipython
from scipy.signal import find_peaks, find_peaks_cwt

minima_mouse = np.zeros((9, len(days), 2), dtype='int') * np.nan
energie_mouse = np.zeros((9, len(days), 2), dtype='int') * np.nan

for idx, mouse in enumerate(options['mice']):
    energy_day = energy_mouse[idx]

    options['mouse'] = mouse
    options = set_options(**options)

    for i, day in enumerate(options['days']):
        locations = np.linspace(0, 360, energy_day[i].shape[0])

        # minimas = find_peaks_cwt(-energy_day[i], widths=np.arange(1, 10))
        # find_multiple_minima_from_values(x_vals, y_vals, num_runs=100, tol=0.05, popsize=2, maxiter=1000, min_distance=35):
        results = find_multiple_minima_from_values(locations, energy_day[i], maxiter=10000, num_runs=2000, min_distance=20).T
        minimas = results[0]
        energies = results[1]
        print(minimas, energies)

        if len(minimas)<2:
            minimas = [minimas[0], minimas[0]]
            energies = [energies[0], energies[0]]

        minima_mouse[idx][i] = minimas[:2]
        energie_mouse[idx][i] = energies[:2]

#+end_src

#+RESULTS:
: [ 21.7292525 360.       ] [0.00482956 0.01151678]
: [28.30569905] [0.00513111]

#+begin_src ipython
y_loc = []
for idx, mouse in enumerate(options['mice']):
     id = ~np.isnan(minima_mouse[idx].T)
     minima = minima_mouse[idx].T

     # y1 = locations[minima[0][id[0]].astype('int')] * np.pi / 180.0
     # y2 = locations[minima[1][id[1]].astype('int')] * np.pi / 180.0

     y1 = minima[0][id[0]].astype('int') * np.pi / 180.0
     y2 = minima[1][id[1]].astype('int') * np.pi / 180.0

     y_mean = (np.sin(y1)+np.sin(y2)) / 2

     while len(y_mean)<len(days):
          y_mean = np.append(y_mean, np.nan)

     y_loc.append(y_mean)

y_loc = np.array(y_loc)

plt.plot(np.arange(1, len(days)+1), np.nanmean(y_loc, 0), '-o')
plt.plot(np.arange(1, len(days)+1), y_loc.T, '-', alpha=.2)

# plt.xticks(np.arange(1, 7))
plt.axhline(0, ls='--', color='k')
plt.xlabel('Day')
plt.ylabel('Y-loc (a.u.)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/dpca/figure_56.png]]

#+begin_src ipython
from scipy.signal import find_peaks
fig, ax = plt.subplots(1, 2, figsize= [2*width, 1*width * golden_ratio])
ax_flat = ax.flatten()

# minima_mouse = np.zeros((9, 6, 2), dtype='int') * np.nan

for idx, mouse in enumerate(options['mice']):
    peaks_list, minimas_list = [], []
    energy_day = energy_mouse[idx]

    options['mouse'] = mouse
    options = set_options(**options)

    ax = ax_flat[idx]

    for i, day in enumerate(options['days']):
        locations = np.linspace(0, 360, energy_day[i].shape[0])
        ax.plot(locations, energy_day[i] * 100 , color=colors[i])
        ax.set_title(mouse)

        # minimas = find_multiple_minima_from_values(locations, energy_day[i])
        minimas = minima_mouse[idx][i]
        energies = energie_mouse[idx][i]
        print(minimas)

        ax.plot(minimas, energies*100, 'o', color=colors[i])

        ax.set_xlabel('Pref Loc (°)')
        ax.set_ylabel('Energy')
        # ax.set_ylim([0, 3])
#+end_src

#+RESULTS:
:RESULTS:
: [ 21.7292525 360.       ]
: [28.30569905 28.30569905]
[[./figures/dpca/figure_57.png]]
:END:

#+begin_src ipython

#+end_src

#+RESULTS:
