#+STARTUP: fold
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session pca :kernel torch :output-dir ./figures/stratpca :file (lc/org-babel-tangle-figure-filename)

* Notebook Settings

#+begin_src ipython
import matplotlib.pyplot
#+end_src

#+RESULTS:


#+begin_src ipython
%load_ext autoreload
%autoreload 2
%reload_ext autoreload

%run /home/leon/dual_task/dual_data/notebooks/setup.py
# %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  from sklearn.exceptions import ConvergenceWarning
  warnings.filterwarnings("ignore")
  import traceback

  import sys
  sys.path.insert(0, '/home/leon/dual_task/dual_data/')

  import os
  if not sys.warnoptions:
    warnings.simplefilter("ignore")
    os.environ["PYTHONWARNINGS"] = "ignore"

  import pickle as pkl
  import numpy as np
  import matplotlib.pyplot as plt
  import pandas as pd
  import seaborn as sns

  from time import perf_counter

  from sklearn.base import clone
  from sklearn.metrics import make_scorer, roc_auc_score
  from sklearn.preprocessing import StandardScaler, RobustScaler
  from sklearn.model_selection import RepeatedStratifiedKFold, LeaveOneOut, StratifiedKFold

  from src.common.plot_utils import add_vlines, add_vdashed
  from src.common.options import set_options
  from src.stats.bootstrap import my_boots_ci
  from src.common.get_data import get_X_y_days, get_X_y_S1_S2
  from src.preprocess.helpers import avg_epochs
  from src.decode.bump import circcvl
  from src.torch.classificationCV import ClassificationCV
  from src.torch.classify import get_classification
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
import numpy as np

class StandardScaler:
    def __init__(self, axis=0, if_scale=1):
        self.axis = axis
        self.center_ = None
        self.scale_ = None
        self.if_scale_ = if_scale

    def fit(self, X):
        self.center_ = np.nanmean(X, axis=self.axis, keepdims=True)
        self.scale_ = np.nanstd(X, axis=(0, -1), keepdims=True)
        # Prevent division by zero
        self.scale_ = np.where(self.scale_==0, 1, self.scale_)
        # self.scale_ = np.where(np.abs(self.scale_)<1e-3, 1, self.scale_)
        return self

    def transform(self, X):
        if self.if_scale_:
            return (X - self.center_) / self.scale_
        return (X - self.center_)

    def fit_transform(self, X):
        self.fit(X)
        return self.transform(X)
#+end_src

#+RESULTS:

#+begin_src ipython
import numpy as np

class RobustScaler:
    def __init__(self, axis=0):
        self.axis = axis
        self.center_ = None
        self.scale_ = None

    def fit(self, X):
        self.center_ = np.nanmedian(X, axis=self.axis, keepdims=True)
        q75 = np.nanpercentile(X, 75, axis=self.axis, keepdims=True)
        q25 = np.nanpercentile(X, 25, axis=self.axis, keepdims=True)
        self.scale_ = q75 - q25
        # Prevent division by zero
        self.scale_ = np.where(self.scale_ == 0, 1, self.scale_)
        return self

    def transform(self, X):
        return (X - self.center_) / self.scale_

    def fit_transform(self, X):
        self.fit(X)
        return self.transform(X)
#+end_src

#+RESULTS:

#+begin_src ipython
def pad_list(arrays, axis=0, max_len=None):
    """
    Pads a list of arrays along the specified axis with NaNs so all have the same size along that axis.
    Returns a list of padded arrays.
    """
    # Find maximum size along specified axis
    if max_len is None:
        max_len = max(arr.shape[axis] for arr in arrays)

    padded = []
    for arr in arrays:
        pad_width = [(0, 0)] * arr.ndim


        n_pad = max_len - arr.shape[axis]

        if n_pad > 0:
            pad_width[axis] = (0, n_pad)
            arr_padded = np.pad(arr, pad_width, mode='constant', constant_values=np.nan)
        else:
            arr_padded = arr
        padded.append(arr_padded)

    return padded
#+end_src

#+RESULTS:

#+begin_src ipython
def avg_cond(X, y, **options):

    X_avg = []
    for i in range(4):
        idx = (y.odor_pair==i)

        if options['trials'] == 'correct':
            correct = ~y.response.str.contains("incorrect")
            idx  = (y.odor_pair==i) & correct

        if idx.mean()>0:
            X_avg.append(np.mean(X[idx], 0))

        # for j in range(2):
        #     idx = (y.sample_odor==i) & (y.choice==j)

        #     if idx.mean()>0:
        #         X_avg.append(np.mean(X[idx], 0))

        # X_avg.append(scaler.fit_transform(X[idx]))

        # for _, task in enumerate(options['tasks']):
        #     idx_task = idx & (y.tasks==task)

        #     if 'Dual' in task:
        #         if options['trials'] == 'correct':
        #             idx_task = idx & (y.tasks==task) & (y.odr_perf==1)

        #     if idx_task.mean()>0:
        #         # X_mean = np.mean(X[(y.tasks==task)], 0)
        #         # X_std = np.std(X[(y.tasks==task)], 0)
        #         # X_avg.append((np.mean(X[idx_task], 0) - X_mean) / X_std)

        #         X_avg.append(np.mean(X[idx_task], 0))

    return np.array(X_avg)
#+end_src

#+RESULTS:

#+RESULTS:

#+begin_src ipython
def pad_with_nans(array, target_shape):
    result = np.full(target_shape, np.nan)  # Create an array filled with NaNs
    print(result.shape)
    slices = tuple(slice(0, min(dim, target)) for dim, target in zip(array.shape, target_shape))
    result[slices] = array[slices]
    return result
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:


#+begin_src ipython :tangle ../src/torch/utils.py
  import pickle as pkl

  def pkl_save(obj, name, path="."):
      os.makedirs(path, exist_ok=True)
      destination = path + "/" + name + ".pkl"
      print("saving to", destination)
      pkl.dump(obj, open(destination, "wb"))


  def pkl_load(name, path="."):
      source = path + "/" + name + '.pkl'
      print('loading from', source)
      return pkl.load(open( source, "rb"))

#+end_src

#+RESULTS:


#+begin_src ipython
from scipy.linalg import orthogonal_procrustes

def align_fold_to_ref(W_fold, W_ref, X_pca_fold):
    """
    Align W_fold to W_ref using orthogonal Procrustes and
    rotate fold's projected data accordingly.

    W_ref, W_fold: (n_comp, n_neurons)
    X_pca_fold: (n_trials, T, n_comp)

    Returns: X_pca_aligned, W_fold_aligned
    """
    if W_ref is None:
        W_ref = W_fold
    # Procrustes finds R that best maps W_fold -> W_ref:  W_fold @ R ≈ W_ref
    R, _ = orthogonal_procrustes(W_fold.T, W_ref.T)  # shapes (n_neurons, n_comp)

    # R is (n_neurons, n_comp), so mapping in component space is R_comp = R.T
    R_comp = R.T  # (n_comp, n_neurons) is W-aligned space; rotation in PC space is R_comp.T

    # rotate projections: (n_trials * T, n_comp) @ (n_comp, n_comp)
    n_trials, T, n_comp = X_pca_fold.shape
    X_flat = X_pca_fold.reshape(-1, n_comp)
    X_aligned = X_flat @ R_comp.T
    X_aligned = X_aligned.reshape(n_trials, T, n_comp)

    W_aligned = (W_fold.T @ R).T  # still (n_comp, n_neurons)
    return X_aligned, W_aligned
#+end_src

#+RESULTS:

#+begin_src ipython
import numpy as np
import itertools
from functools import reduce
import operator

def cv_avg_cond(X, y, condition='odor_pair'):
    # Ensure condition is a list
    if isinstance(condition, str):
        condition = [condition]

    # Find unique values for each condition
    unique_vals = [y[c].unique() for c in condition]

    X_avg = []
    combos = list(itertools.product(*unique_vals))
    for combo in combos:
        # Build boolean mask for all conditions
        idx = reduce(operator.and_, [(y[c]==v) for c,v in zip(condition, combo)])
        if idx.any():
            X_avg.append(np.mean(X[idx], axis=0))

    return np.array(X_avg)
#+end_src

#+RESULTS:

#+begin_src ipython
from sklearn.model_selection import KFold, StratifiedKFold, RepeatedStratifiedKFold
from sklearn.decomposition import PCA
from tqdm import tqdm

def cross_val_avg_pca(X, y, n_splits, n_repeats, n_comp, epoch, condition, scaler=None):

    if scaler is not None:
        scaler = StandardScaler(axis=0, if_scale=1)

    pca = PCA(n_components=n_comp, svd_solver='randomized')
    # kf = StratifiedKFold(n_splits=n_splits, shuffle=True)
    kf = RepeatedStratifiedKFold(n_splits=n_splits, n_repeats=n_repeats)

    labels = y['mouse'].astype(str) + '_' + y['odor_pair'].astype(str) + '_' + y['tasks'].astype(str) + '_' + y['laser'].astype(str)

    X_folds, y_folds = [], []
    w_folds, evr_folds = [], []
    w_ref = None
    for train_idx, test_idx in tqdm(kf.split(X, labels), total=kf.get_n_splits(X, labels)):

        X_train, y_train = X[train_idx], y.iloc[train_idx]

        # m_train = (y_train.performance==1) & (y_train.tasks=='DPA')
        # m_train = (y_train.performance==1) & ((y_train.tasks=='DPA') | (y_train.odr_perf==1)) & (y_train.laser==0)
        m_train = (y_train.laser==0)

        X_train = X_train[m_train]
        y_train = y_train[m_train]

        if scaler is not None:
            X_train = scaler.fit_transform(X_train)
        X_train_epoch = X_train[..., epoch]

        X_train_flat = X_train_epoch.transpose(0, 2, 1).reshape(-1, X_train_epoch.shape[1])
        X_mean = np.nanmean(X_train_flat, axis=0, keepdims=True)

        X_avg_epoch = cv_avg_cond(X_train_epoch, y_train, condition)
        X_avg_flat = X_avg_epoch.transpose(0, 2, 1).reshape(-1, X_avg_epoch.shape[1])
        X_cent = X_avg_flat - X_mean

        pca.fit(X_cent)
        w_fold = pca.components_
        evr_folds.append(pca.explained_variance_ratio_)

        X_test, y_test = X[test_idx], y.iloc[test_idx]
        if scaler is not None:
            X_test = scaler.transform(X_test)

        X_test_flat = X_test.transpose(0, 2, 1).reshape(-1, X_test.shape[1])
        X_cent_test = X_test_flat - X_mean
        X_out = pca.transform(X_cent_test).reshape(X_test.shape[0], X_test.shape[-1], -1)

        X_pca_aligned, w_fold_aligned = align_fold_to_ref(w_fold, w_ref, X_out)

        w_folds.append(w_fold_aligned)

        if w_ref is None:
                w_ref = w_folds[0]

        X_folds.append(X_pca_aligned)
        y_folds.append(y_test)

    X_folds = np.concatenate(X_folds, 0)
    y_folds = pd.concat(y_folds)

    w_folds = np.array(w_folds, dtype=object)
    evr_folds = np.array(evr_folds, dtype=object)

    return X_folds, y_folds, w_folds, evr_folds
#+end_src

#+RESULTS:


#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter

def polar_velocities(x, y, sigma_r=1, sigma_t=10):
    """
    x, y: (n_traj, n_points)
    sigma: gaussian smoothing in time (in points)
    Returns:
      dr_s, dtheta_s: (n_traj, n_points): smoothed radial and angular velocities
      r, theta: positions at each point, for later conversion
    """
    # Polar coords
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    # Derivatives
    dr = np.gradient(r, axis=1)

    # Handle angle wrapping
    dtheta = np.unwrap(theta, axis=1)
    dtheta = np.gradient(dtheta, axis=1)

    # Smoothing
    dr_s = gaussian_filter(dr, sigma=sigma_r)
    dtheta_s = gaussian_filter(dtheta, sigma=sigma_t)

    return dr_s, dtheta_s, r, theta

def pol2cart(dr, dtheta, r, theta):
    """
    Converts smoothed polar velocities to Cartesian velocities.
    All arrays shape: (n_traj, n_points)
    """
    u = dr * np.cos(theta) - r * dtheta * np.sin(theta)
    v = dr * np.sin(theta) + r * dtheta * np.cos(theta)
    return u, v

def create_field(x, y, u, v, grid_size=100, method='linear', z_lim=5):
    """
    Interpolate velocity field to a regular grid.
    Inputs: x,y,u,v all (n_samples,) or (n_traj, n_points) -- flatten them first.
    Returns: xi, yi, ui, vi: all (grid_size, grid_size) arrays.
    """
    x_flat = x.flatten()
    y_flat = y.flatten()
    u_flat = u.flatten()
    v_flat = v.flatten()

    # xi, yi = np.meshgrid(
    #     np.linspace(np.min(x_flat), np.max(x_flat), grid_size),
    #     np.linspace(np.min(y_flat), np.max(y_flat), grid_size),
    # )

    x_min, x_max = np.min(x_flat)-1, np.max(x_flat)+1
    y_min, y_max = np.min(y_flat)-1, np.max(y_flat)+1

    if z_lim is 0:
        z_min = np.min((x_min, y_min))
        z_max = np.min((x_max, y_max))
    else:
        z_min = -z_lim
        z_max = z_lim

    xi, yi = np.meshgrid(np.linspace(z_min, z_max, grid_size),
                         np.linspace(z_min, z_max, grid_size))


    ui = griddata((x_flat, y_flat), u_flat, (xi, yi), method=method, fill_value=np.nan)
    vi = griddata((x_flat, y_flat), v_flat, (xi, yi), method=method, fill_value=np.nan)

    # Fill nans with nearest
    mask = np.isnan(ui)
    if np.any(mask):
        ui[mask] = griddata((x_flat, y_flat), u_flat, (xi, yi), method='nearest')[mask]
        vi[mask] = griddata((x_flat, y_flat), v_flat, (xi, yi), method='nearest')[mask]

    return xi, yi, ui, vi

def plot_field(xi, yi, ui, vi, ax=None, density=1.0, show_cbar=0):
    speed = np.sqrt(ui**2 + vi**2)
    if ax is None:
        fig, ax = plt.subplots(figsize=(5,5))
    # Normalize for coloring
    import matplotlib as mpl
    vmin, vmax = np.nanpercentile(speed, [5, 95])
    norm = mpl.colors.Normalize(vmin, vmax)
    # strm = ax.streamplot(xi, yi, ui, vi, density=density, color=speed, cmap='coolwarm', norm=norm)
    heatmap = ax.pcolormesh(xi, yi, speed, cmap='coolwarm', shading='gouraud', norm=norm)

    if show_cbar:
        plt.colorbar(strm.lines, ax=ax, label='Speed')

    ax.set_aspect('equal')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    return ax
#+end_src

#+RESULTS:

* Parameters

#+begin_src ipython
old_mice = ['ChRM04','JawsM15', 'JawsM18', 'ACCM03', 'ACCM04']
Jaws_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18']

mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18', 'ChRM04', 'ChRM23', 'ACCM03', 'ACCM04']
laser_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18', 'ChRM04', 'ChRM23']
# mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18', 'ChRM04', 'ChRM23']
# mice = ['JawsM15', 'JawsM18', 'ChRM04']

tasks = ['Dual'] # all

kwargs = {
   'mice': mice,
   'tasks': tasks,
   'mouse': mice[0], 'laser': 0,
   'trials': '', 'reload': 0, 'data_type': 'dF',
   'prescreen': None, 'pval': 0.05,
   'preprocess': False, 'scaler_BL': 'standard',
   'avg_noise':False, 'unit_var_BL': False,
   'random_state': None, 'T_WINDOW': 0.0,
   'l1_ratio': 0.95,
   'n_comp': 3, 'pca': 'pca',
   'scaler': None,
   'bootstrap': 1, 'n_boots': 128,
   'n_splits': 5, 'n_repeats': 10,
   'class_weight': 0,
   'multilabel': 0,
   'mne_estimator':'generalizing', # sliding or generalizing
   'n_jobs': 64,
}

# kwargs['days'] = ['first', 'middle', 'last']
kwargs['days'] = ['first', 'last']
# kwargs['days'] = 'all'
options = set_options(**kwargs)
options['cv_B'] = False
#+end_src

#+RESULTS:

#+begin_src ipython
options['learning'] = 'Expert'
options['laser'] = 0

options['epochs'] = ['TEST']
epoch = options['bins_' + options['epochs'][0]]
condition = 'odor_pair'
#+end_src

#+RESULTS:

* Load Data

#+begin_src ipython
X_trials, y_trials = [], []

n_neurons = 3319
counter = 0
for mouse in options['mice']:

    options['mouse'] = mouse
    options = set_options(**options)
    X, y = get_X_y_days(**options)

    print(mouse, X.shape, y.shape, options['n_days'])

    X_scale = X.copy()
    for day in range(1, options['n_days']+1):
        idx = (y.day==day) & (y.laser==0)

        mean_ = np.nanmean(X[idx], 0, keepdims=1)
        std_ = np.nanstd(X[idx], (0, -1), keepdims=1)
        std_ = np.where(std_==0, 1, std_)

        X_scale[idx] = (X[idx] - mean_) / std_

        idx = (y.day==day) & (y.laser==1)
        X_scale[idx] = (X[idx] - mean_) / std_

    X_trial = np.zeros((X.shape[0], n_neurons, X.shape[-1])) * np.nan
    X_trial[:, counter:X.shape[1]+counter, :] = X_scale

    counter += X.shape[1]

    X_trials.append(X_trial)

    y['mouse'] = mouse
    y_trials.append(y)

X_trials = np.array(X_trials, dtype=object)
y_trials = np.array(y_trials, dtype=object)
#+end_src

#+RESULTS:
: JawsM01 (768, 184, 84) (768, 15) 4
: JawsM06 (1152, 201, 84) (1152, 15) 6
: JawsM12 (960, 423, 84) (960, 15) 5
: JawsM15 (1152, 693, 84) (1152, 15) 6
: JawsM18 (1152, 444, 84) (1152, 15) 6
: ChRM04 (1152, 668, 84) (1152, 15) 6
: ChRM23 (960, 232, 84) (960, 15) 5
: ACCM03 (960, 361, 84) (960, 15) 5
: ACCM04 (960, 113, 84) (960, 15) 5

#+begin_src ipython
X_all = np.concatenate(X_trials, 0)
y_all = pd.concat(y_trials)
print(X_all.shape, y_all.shape)
#+end_src

#+RESULTS:
: (9216, 3319, 84) (9216, 16)

#+begin_src ipython
pkl_save(X_all, 'X_all', path="../data/pca")
pkl_save(y_all, 'y_all', path="../data/pca")
#+end_src

#+RESULTS:
: saving to ../data/pca/X_all.pkl
: saving to ../data/pca/y_all.pkl

* Meta Mouse
** Load

#+begin_src ipython
X_all = pkl_load('X_all', path="../data/pca")
y_all = pkl_load('y_all', path="../data/pca")
#+end_src

#+RESULTS:
: loading from ../data/pca/X_all.pkl
: loading from ../data/pca/y_all.pkl

#+begin_src ipython
print(y_all.keys())
#+end_src

#+RESULTS:
: Index(['sample_odor', 'dist_odor', 'test_odor', 'tasks', 'response', 'laser',
:        'day', 'choice', 'pair', 'odr_perf', 'odr_choice', 'odr_response',
:        'odor_pair', 'learning', 'performance', 'mouse'],
:       dtype='object')

** Model

#+begin_src ipython
idx = (y_all.learning == options['learning'])  # & (~y_all['mouse'].str.contains('ACC')) # & (y_all.laser==options['laser']) # & (y_all.tasks!='DPA')

X_pca = X_all[idx]
y_pca = y_all[idx]

X_pca[np.isnan(X_pca)] = 0

print('laser', options['laser'])
print(X_pca.shape, y_pca.shape)
print(y_pca.mouse.unique())
print(y_pca.odor_pair.unique())
print(y_pca.tasks.unique())
#+end_src

#+RESULTS:
: laser 0
: (4032, 3319, 84) (4032, 16)
: ['JawsM01' 'JawsM06' 'JawsM12' 'JawsM15' 'JawsM18' 'ChRM04' 'ChRM23'
:  'ACCM03' 'ACCM04']
: [1. 2. 3. 0.]
: ['DualNoGo' 'DualGo' 'DPA']

 #+begin_src ipython
# pca = PCA(n_components=3)
# scaler = StandardScaler(axis=0)

# # fit on full data
# X_scaled = scaler.fit_transform(X)
# X_avg = cv_avg_cond(X_scaled, y.copy(), condition)
# X_flat = X_avg[..., epoch].transpose(0, 2, 1).reshape(-1, X_avg.shape[1])
# X_mean = np.nanmean(X_flat, 0, keepdims=1)
# X_cent = (X_flat - X_mean)

# pca.fit(X_cent)
# w_all = pca.components_
# evr_all = pca.explained_variance_ratio_

# X_flat = X_scaled.transpose(0, 2, 1).reshape(-1, X_scaled.shape[1])
# X_mean = np.nanmean(X_flat, 0, keepdims=1)
# X_cent = (X_flat - X_mean)

# X_pca = pca.transform(X_cent).reshape(X_scaled.shape[0], X_scaled.shape[-1], -1)
#+end_src

#+RESULTS:

#+begin_src ipython
n_splits = 5
n_repeats = 1
n_comp = 3

X_cv, y_cv, w_cv, evr_cv = cross_val_avg_pca(X_pca, y_pca, n_splits, n_repeats, n_comp, epoch, condition)
#+end_src

#+RESULTS:
: 100% 5/5 [00:39<00:00,  7.99s/it]

#+begin_src ipython
print(X_cv.shape, y_cv.shape, w_cv.shape, evr_cv.shape)
#+end_src

#+RESULTS:
: (4032, 84, 3) (4032, 16) (5, 3, 3319) (5, 3)

#+begin_src ipython
X_meta = np.array(X_cv, dtype=float)
X_meta = np.swapaxes(X_meta, 1, 2)
y_meta = y_cv
evr_meta = evr_cv
w_meta = np.mean(w_cv, 0, dtype=float) * 100
print(X_meta.shape, y_meta.shape, w_meta.shape)
#+end_src

#+RESULTS:
: (4032, 3, 84) (4032, 16) (3, 3319)

** Save/Load

#+begin_src ipython
dum = options['epochs'][0] + '_' + options['learning'] + '_laser_%d' % options['laser']
print(dum)
#+end_src

#+RESULTS:
: TEST_Expert_laser_0

#+begin_src ipython
pkl_save(X_meta, 'meta_traj_' + dum, path="../data/pca/")
pkl_save(y_meta, 'meta_labels_' + dum, path="../data/pca/")
pkl_save(w_meta, 'meta_weights_' + dum, path="../data/pca/")
pkl_save(evr_meta, 'meta_evr_' + dum, path="../data/pca/")
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: NameError                                 Traceback (most recent call last)
: Cell In[18], line 1
: ----> 1 pkl_save(X_meta, 'meta_traj_' + dum, path="../data/pca/")
:       2 pkl_save(y_meta, 'meta_labels_' + dum, path="../data/pca/")
:       3 pkl_save(w_meta, 'meta_weights_' + dum, path="../data/pca/")
:
: NameError: name 'X_meta' is not defined
:END:

#+begin_src ipython
X_meta = pkl_load('meta_traj_' + dum, path="../data/pca/")
y_meta = pkl_load( 'meta_labels_' + dum, path="../data/pca/")
w_meta = pkl_load( 'meta_weights_' + dum, path="../data/pca/")
evr_meta = pkl_load( 'meta_evr_' + dum, path="../data/pca/")
#+end_src

#+RESULTS:
: loading from ../data/pca//meta_traj_TEST_Expert_laser_0.pkl
: loading from ../data/pca//meta_labels_TEST_Expert_laser_0.pkl
: loading from ../data/pca//meta_weights_TEST_Expert_laser_0.pkl
: loading from ../data/pca//meta_evr_TEST_Expert_laser_0.pkl

#+begin_src ipython

#+end_src

#+RESULTS:

** Trajectories

#+begin_src ipython
n_comp = 3
laser = 0
i_mouse=4

idx_mouse = True
if i_mouse !=-1:
    idx_mouse = (y_meta.mouse==options['mice'][i_mouse])
#+end_src

#+RESULTS:

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height),)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = ['AC', 'AD', 'BD', 'BC']
xtime = np.linspace(0, 14, 84)

for i in range(4):
    mask = (y_meta.odor_pair==i) & (y_meta.laser==laser) & idx_mouse
    X_sel = X_meta[mask]

    X_avg = np.mean(X_sel, 0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = np.std(X_sel, 0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)

        ax[k].legend(fontsize=12, frameon=0, loc='best')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_31.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = y_meta.tasks.unique()
xtime = np.linspace(0, 14, 84)

for i in range(len(pair)):
    mask = (y_meta.tasks==y_meta.tasks.unique()[i]) & (y_meta.laser==laser) & idx_mouse
    X_sel = X_meta[mask]

    X_avg = X_sel.mean(0)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=0)

        ax[k].legend(fontsize=12, frameon=0, loc='best')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_32.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8", "#984ea3", "#4daf4a", "#ffae19"]

pair = ['A', 'B']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_meta.sample_odor.values==i) & (y_meta.laser==laser) & idx_mouse
    X_sel = X_meta[mask]          # Subselect rows
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_33.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8",  "#ffae19"]

pair = ['unpair', 'pair']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_meta.pair==i) & (y_meta.laser==laser) & idx_mouse
    X_sel = X_meta[mask]          # Subselect rows
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_34.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8", "#4daf4a"]

pair = ['nolick', 'lick']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_meta.choice==i) & (y_meta.laser==laser) & idx_mouse
    X_sel = X_meta[mask]          # Subselect rows
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_35.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8", "#4daf4a"]

pair = ['C', 'D']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_meta.test_odor==i) & (y_meta.laser==0) & idx_mouse
    X_sel = X_meta[mask]
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_36.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=3, figsize=(3*width, height))

pair = ['AC', 'AD', 'BD', 'BC']

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

for i in range(4):
    idx = (y_meta.odor_pair==i) & (y_meta.laser==laser) & idx_mouse

    X_avg = (X_meta[idx].mean(0))[:, :66]

    ax[0].plot(X_avg[0], X_avg[1], color=color[i], label=pair[i])
    ax[0].set_xlabel('PC 1')
    ax[0].set_ylabel('PC 2')

    ax[1].plot(X_avg[0], X_avg[2], color=color[i], label=pair[i])
    ax[1].set_xlabel('PC 1')
    ax[1].set_ylabel('PC 3')

    ax[2].plot(X_avg[1], X_avg[2], color=color[i], label=pair[i])
    ax[2].set_xlabel('PC 2')
    ax[2].set_ylabel('PC 3')

for k in range(3):
    ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_37.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Embeddings
*** spatial filter

#+begin_src ipython
z_lim =5
size = 0.1

import cmocean
cmap=cmocean.cm.phase

theta = np.arctan2(w_meta[0], w_meta[1]) * 180 / np.pi
idx = np.argsort(theta)

theta_norm = (theta+ 360) % (360)

counts, bins, patches = plt.hist(theta_norm, bins='auto', range=(0, 360), density=1)

bin_centers = 0.5*(bins[:-1] + bins[1:])
colors = [cmap(center/(360)) for center in bin_centers]

for patch, color in zip(patches, colors):
    patch.set_facecolor(color)

plt.xlabel('Neuron Loc (°)')
plt.ylabel('Density')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_39.png]]

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d, gaussian_filter1d
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height))

for k in range(n_comp):
    sc = ax[k].scatter(theta[idx], w_meta[k][idx], alpha=0.5, c=theta_norm[idx], cmap=cmap)
    ax[k].plot(theta[idx], gaussian_filter1d(w_meta[k][idx], int(size*w_meta.shape[1]), mode='wrap'), 'k')
    ax[k].axhline(0, ls='--', color='k')
    ax[k].set_ylabel('Weights PC %d' % (k+1))
    ax[k].set_xlabel('Neuron Loc (°)')
    ax[k].set_ylim([-z_lim, z_lim])

ax[-1].set_ylim([-z_lim/2, z_lim/2])
plt.colorbar(sc, ax=ax[-1], label='Angle (°)')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_40.png]]

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d, uniform_filter1d
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, width))

ax[0].scatter(w_meta[0][idx], w_meta[1][idx], c=theta_norm[idx], cmap=cmap, alpha=0.5)
ax[0].plot(gaussian_filter1d(w_meta[0][idx], int(size*w_meta.shape[1]), mode='wrap'), gaussian_filter1d(w_meta[1][idx], int(size*w_meta.shape[1]), mode='wrap'), 'k')

ax[0].set_xlabel('PC 1')
ax[0].set_ylabel('PC 2')

ax[1].scatter(w_meta[0][idx], w_meta[2][idx], c=theta_norm[idx], cmap=cmap, alpha=0.5)
ax[1].plot(gaussian_filter1d(w_meta[0][idx], int(size*w_meta.shape[1]), mode='wrap'), gaussian_filter1d(w_meta[2][idx], int(size*w_meta.shape[1]), mode='wrap'), 'k')
ax[1].set_xlabel('PC 1')
ax[1].set_ylabel('PC 3')

sc = ax[2].scatter(w_meta[1][idx], w_meta[2][idx], c=theta_norm[idx], cmap=cmap, alpha=0.5)
ax[2].plot(gaussian_filter1d(w_meta[1][idx], int(size*w_meta.shape[1]), mode='wrap'), gaussian_filter1d(w_meta[2][idx], int(size*w_meta.shape[1]), mode='wrap'), 'k')
ax[2].set_xlabel('PC 2')
ax[2].set_ylabel('PC 3')

for k in range(3):
    ax[k].set_xlim(-z_lim, z_lim)
    ax[k].set_ylim(-z_lim, z_lim)

plt.colorbar(sc, ax=ax[-1], label='Angle (°)')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_41.png]]

#+begin_src ipython
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

ax.plot(gaussian_filter1d(w_meta[0][idx], int(size*w_meta.shape[1]), mode='wrap'),
           gaussian_filter1d(w_meta[1][idx], int(size*w_meta.shape[1]), mode='wrap'),
           gaussian_filter1d(w_meta[2][idx], int(size*w_meta.shape[1]), mode='wrap'),
           rasterized=1, color='k')


sc = ax.scatter(w_meta[0][idx],
                w_meta[1][idx],
                w_meta[2][idx],
                c=theta_norm[idx], cmap=cmap,
                rasterized=1, alpha=0.5)

ax.tick_params(axis='both', which='major', labelsize=12)  # change both x and y (and z in 3D)
ax.tick_params(axis='z', which='major', labelsize=12)     # for the z-axis specifically

ax.set_xlabel('PC 1', fontsize=12)
ax.set_ylabel('PC 2', fontsize=12)
ax.set_zlabel('PC 3', fontsize=12)

ax.set_xlim([-z_lim, z_lim])
ax.set_ylim([-z_lim, z_lim])
ax.set_zlim([-z_lim/10, z_lim/10])

ax.grid(False)

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_42.png]]

*** theta space

#+begin_src ipython
nbins = 32
theta_bins = np.linspace(0, 360, nbins+1)
theta_digitized = np.digitize(theta_norm, theta_bins) - 1

# For each bin, average w[0], w[1], and w[2]
w_binned = np.zeros((3, nbins))
for i in range(nbins):
    mask = theta_digitized == i
    for j in range(3):
        w_binned[j, i] = np.mean(w_meta[j][mask]) if np.any(mask) else np.nan

w_smooth = gaussian_filter1d(w_binned, sigma=3, axis=1, mode='wrap')
#+end_src


#+RESULTS:

#+begin_src ipython
import matplotlib.pyplot as plt
from numpy import deg2rad

bin_centers = 0.5 * (theta_bins[:-1] + theta_bins[1:])
theta_plot = deg2rad(bin_centers)

fig, axs = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height))

for i, ax in enumerate(axs):
    ax.plot(theta_plot * 180 / np.pi, w_smooth[i], lw=2)
    ax.axhline(0, ls='--', color='k')
    ax.set_ylabel('Weights PC %d' % (i+1))
    ax.set_xlabel('Neuron Loc (°)')

axs[-1].axvline(45)
axs[-1].axvline(225)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_44.png]]

#+begin_src ipython
import matplotlib.pyplot as plt
from numpy import deg2rad

# Compute bin centers in degrees and radians
bin_centers = 0.5 * (theta_bins[:-1] + theta_bins[1:])
theta_plot = deg2rad(bin_centers)  # for polar plots

fig, axs = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, width), sharey=1)

# PC1 vs PC2
axs[0].plot(w_smooth[0], w_smooth[1], 'k-')
axs[0].set_xlabel('PC 1')
axs[0].set_ylabel('PC 2')

# PC1 vs PC3
axs[1].plot(w_smooth[0], w_smooth[2], 'k-')
axs[1].set_xlabel('PC 1')
axs[1].set_ylabel('PC 3')

# PC2 vs PC3
axs[2].plot(w_smooth[1], w_smooth[2], 'k-')
axs[2].set_xlabel('PC 2')
axs[2].set_ylabel('PC 3')

plt.tight_layout()
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_45.png]]

#+begin_src ipython
import matplotlib.pyplot as plt
from numpy import deg2rad

bin_centers = 0.5 * (theta_bins[:-1] + theta_bins[1:])
theta_plot = deg2rad(bin_centers)

fig, axs = plt.subplots(1, 3, subplot_kw={'polar': True}, figsize=(n_comp*width, width))

for i, ax in enumerate(axs):
    ax.plot(theta_plot, w_smooth[i], lw=2)

plt.tight_layout()
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_46.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Opto

#+begin_src ipython
laser_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15','JawsM18', 'ChRM04', 'ChRM23']
laser_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM18', 'ChRM04', 'ChRM23']
# laser_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15','JawsM18']

traj_mouse = []
for i_mouse, mouse in enumerate(laser_mice):
    idx = (y_meta.mouse==mouse) & (y_meta.laser==0)
    X_idx = X_meta[idx]
    y_idx = y_meta[idx]

    traj_ = []
    for i in range(2):
        mask = (y_idx.sample_odor==i)  & (y_idx.tasks=='DPA') # & (y_idx.performance==1) & ((y_idx.tasks=='DPA') | (y_idx.odr_perf==1))
        traj_.append(X_idx[mask].mean(0))

    traj_mouse.append(traj_)

traj_mouse = np.array(traj_mouse)
print(traj_mouse.shape)
#+end_src

#+RESULTS:
: (6, 2, 3, 84)

#+begin_src ipython
traj_opto = []
for i_mouse, mouse in enumerate(laser_mice):
    idx = (y_meta.mouse==mouse) & (y_meta.laser==1)
    X_idx = X_meta[idx]
    y_idx = y_meta[idx]

    traj_ = []
    for i in range(2):
        mask = (y_idx.sample_odor==i) & (y_idx.tasks=='DPA') # & (y_idx.performance==1) & ((y_idx.tasks=='DPA') | (y_idx.odr_perf==1))
        traj_.append(X_idx[mask].mean(0))

    traj_opto.append(traj_)

traj_opto = np.array(traj_opto)
print(traj_opto.shape)
#+end_src

#+RESULTS:
: (6, 2, 3, 84)

#+begin_src ipython
fp_mouse = np.nanmean(traj_mouse[..., options['bins_LD']], -1)
fp_opto = np.nanmean(traj_opto[..., options['bins_LD']], -1)

print(fp_mouse.shape)

pc1 = fp_mouse[..., 0]
pc2 = fp_mouse[..., 1]

pc1_opto = fp_opto[..., 0]
pc2_opto = fp_opto[..., 1]
#+end_src

#+RESULTS:
: (6, 2, 3)

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(2*height, height), sharey=1)

for i in range(pc1.shape[0]):
    ax[0].scatter(pc1[i], pc2[i], label=options['mice'][i])
    ax[1].scatter(pc1_opto[i], pc2_opto[i], label=options['mice'][i])

for k in range(2):
    ax[k].axvline(0, color='k')
    ax[k].axhline(0, color='k')

    ax[k].set_xlabel('PC1')
    ax[k].set_ylabel('PC2')
# plt.legend(fontsize=12, frameon=0)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_51.png]]

#+begin_src ipython
perf_off = y_meta[y_meta['mouse'].isin(laser_mice) & (y_meta.laser==0)].groupby(['mouse', 'sample_odor'])['performance'].mean().reset_index()
perf_on = y_meta[y_meta['mouse'].isin(laser_mice) & (y_meta.laser==1)].groupby(['mouse', 'sample_odor'])['performance'].mean().reset_index()

delta_dpa = (perf_on['performance'] - perf_off['performance']).values
print(perf_off.shape, perf_on.shape)
print(delta_dpa)
#+end_src

#+RESULTS:
: (12, 3) (12, 3)
: [ 0.00694444  0.03472222  0.0625      0.02083333  0.          0.
:   0.00694444 -0.04166667  0.01041667  0.09375     0.00694444 -0.00694444]

#+begin_src ipython
perf_off = y_meta[y_meta['mouse'].isin(laser_mice) & (y_meta.laser==0)].groupby(['mouse', 'sample_odor'])['odr_perf'].mean().reset_index()
perf_on = y_meta[y_meta['mouse'].isin(laser_mice) & (y_meta.laser==1)].groupby(['mouse', 'sample_odor'])['odr_perf'].mean().reset_index()

delta_odr = (perf_on['odr_perf'] - perf_off['odr_perf']).values
print(perf_off.shape, perf_on.shape)
print(delta_odr)
#+end_src

#+RESULTS:
: (12, 3) (12, 3)
: [-0.05208333 -0.02083333 -0.015625   -0.0625      0.03125    -0.03125
:  -0.02083333  0.          0.          0.015625   -0.02083333  0.02083333]

#+begin_src ipython
dPC1 = (pc1_opto - pc1).reshape(-1)
dPC2 = (pc2_opto - pc2).reshape(-1)
print(dPC1.shape, dPC2.shape)
#+end_src

#+RESULTS:
: (12,) (12,)

#+begin_src ipython
df = perf_off[['mouse', 'sample_odor']]
df['delta_dpa'] = delta_dpa
df['delta_odr'] = delta_odr

df['mouse'] = pd.Categorical(df['mouse'], categories=laser_mice, ordered=True)
df = df.sort_values('mouse')

df['delta_pc1'] = dPC1
df['delta_pc2'] = dPC2

# df = df[~df['mouse'].str.contains('ChR')]

print(df.head())
#+end_src

#+RESULTS:
:      mouse  sample_odor  delta_dpa  delta_odr  delta_pc1  delta_pc2
: 4  JawsM01          0.0   0.000000   0.031250  -0.162048  -0.255096
: 5  JawsM01          1.0   0.000000  -0.031250  -0.074049  -0.206603
: 6  JawsM06          0.0   0.006944  -0.020833  -0.179361   0.137730
: 7  JawsM06          1.0  -0.041667   0.000000  -0.077506   0.081813
: 8  JawsM12          0.0   0.010417   0.000000   0.467736  -0.514301

#+begin_src ipython
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import pearsonr

fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(2*width, height), sharey=1)

df_ = df.copy()

for i, delta_perf in enumerate(['delta_dpa', 'delta_odr']):
    sns.regplot(data=df_, x='delta_pc1', y=delta_perf, scatter=True,
                fit_reg=True, ci=95, ax=ax[i],
                scatter_kws={'s': 0, 'alpha': 0.7},
                line_kws={'color': 'k', 'lw': 2, 'ls':'--'})

    sns.scatterplot(data=df_, x='delta_pc1', y=delta_perf,
                    hue='mouse', style=None, s=80, alpha=0.8, ax=ax[i],
                    legend=None)

    corr, p_value = pearsonr(df_['delta_pc1'].dropna(), df_[delta_perf].dropna())

    annotation = f"Pearson r = {corr:.2f}\np-value = {p_value:.3f}"
    ax[i].annotate(annotation, xy=(.65, 0.95), xycoords='axes fraction', fontsize=14,
                backgroundcolor='white', verticalalignment='top', horizontalalignment='left',
                bbox=dict(edgecolor=None, facecolor='white', boxstyle='round'))

    ax[i].set_xlabel("$\\Delta$ PC1")
    ax[i].set_ylabel("$\\Delta$ Performance")

ax[0].set_ylabel("$\\Delta$ Performance")
ax[1].set_ylabel("")
# plt.savefig('./figures/bernstein/gng_corr.svg', dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_56.png]]

#+begin_src ipython
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import pearsonr

fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(2*width, height), sharey=1)

df_ = df.copy()

for i, delta_perf in enumerate(['delta_dpa', 'delta_odr']):
    sns.regplot(data=df_, x='delta_pc2', y=delta_perf, scatter=True,
                fit_reg=True, ci=95, ax=ax[i],
                scatter_kws={'s': 0, 'alpha': 0.7},
                line_kws={'color': 'k', 'lw': 2, 'ls':'--'})

    sns.scatterplot(data=df_, x='delta_pc2', y=delta_perf,
                    hue='mouse', style=None, s=80, alpha=0.8, ax=ax[i],
                    legend=None)

    corr, p_value = pearsonr(df_['delta_pc2'].dropna(), df_[delta_perf].dropna())

    annotation = f"Pearson r = {corr:.2f}\np-value = {p_value:.3f}"
    ax[i].annotate(annotation, xy=(.65, 0.95), xycoords='axes fraction', fontsize=14,
                backgroundcolor='white', verticalalignment='top', horizontalalignment='left',
                bbox=dict(edgecolor=None, facecolor='white', boxstyle='round'))

    ax[i].set_xlabel("$\\Delta$ PC2")

ax[0].set_ylabel("$\\Delta$ Performance")
ax[1].set_ylabel("")

# plt.savefig('./figures/bernstein/gng_corr.svg', dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_57.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Flow fields

#+begin_src ipython
import numpy as np

n_trials = 96
n_time   = 84
grid_size = 15  # 0..14 in each dimension

# Arrays to hold positions: shape (trials, time)
x_coor = np.zeros((n_trials, n_time), dtype=int)
y_coor = np.zeros((n_trials, n_time), dtype=int)

# Define possible moves: up, down, left, right
moves = np.array([
    [ 1,  0],  # right
    [-1,  0],  # left
    [ 0,  1],  # up
    [ 0, -1],  # down
])

# Initialize starting positions randomly on the grid
x_coor[:, 0] = np.random.randint(0, grid_size, size=n_trials)
y_coor[:, 0] = np.random.randint(0, grid_size, size=n_trials)

for t in range(1, n_time):
    # choose a random move for each trial
    step_indices = np.random.randint(0, len(moves), size=n_trials)
    steps = moves[step_indices]  # shape (n_trials, 2)

    # update positions
    x_coor[:, t] = x_coor[:, t-1] + steps[:, 0]
    y_coor[:, t] = y_coor[:, t-1] + steps[:, 1]

    # enforce grid boundaries (reflecting)
    x_coor[:, t] = np.clip(x_coor[:, t], 0, grid_size - 1)
    y_coor[:, t] = np.clip(y_coor[:, t], 0, grid_size - 1)

# x_coor and y_coor are now shape (96, 84) with random walk trajectories
print(x_coor.shape, y_coor.shape)
#+end_src

#+RESULTS:
: (96, 84) (96, 84)

#+begin_src ipython
n_comp = 3
laser = 0
i_mouse = 3

idx_mouse = True
if i_mouse !=-1:
    idx_mouse = (y_meta.mouse==options['mice'][i_mouse])
#+end_src

#+RESULTS:

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d, uniform_filter1d

z_lim=15
gsize=32

sigma_r=5
sigma_t=15

idx = (y_meta.tasks=='DPA') & (y_meta.laser==0) & (y_meta.mouse==options['mice'][i_mouse])

X_delay = X_meta[idx].copy()

x_coor = X_delay[:, 0]
y_coor = X_delay[:, 1]
#+end_src

#+RESULTS:

*** binned

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy.ndimage import gaussian_filter1d
from scipy.interpolate import Rbf


# =========================
# Basic polar conversion
# =========================

def cart2polar(x, y):
    """
    x, y: (n_traj, n_points)
    Returns:
      r, theta (r>=0, theta in [-pi, pi])
    """
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)
    return r, theta


# =========================
# Time smoothing only (per trajectory)
# =========================

def smooth_polar_time(x, y, sigma_r_time=1.0, sigma_t_time=10.0, dt=1.0):
    """
    Smooth r, theta along time for each trajectory (no cross-trajectory mixing).

    x, y: (n_traj, n_points)

    Returns:
      dr_s, dtheta_s, r_s, theta_s
    """
    r, theta = cart2polar(x, y)

    # smooth r in time
    r_s = gaussian_filter1d(r, sigma=sigma_r_time, axis=1, mode='nearest')

    # smooth theta in time via cos/sin (circular)
    c = np.cos(theta)
    s = np.sin(theta)
    c_s = gaussian_filter1d(c, sigma=sigma_t_time, axis=1, mode='nearest')
    s_s = gaussian_filter1d(s, sigma=sigma_t_time, axis=1, mode='nearest')
    mag = np.sqrt(c_s**2 + s_s**2) + 1e-12
    c_s /= mag
    s_s /= mag
    theta_s = np.arctan2(s_s, c_s)

    # velocities from smoothed positions
    dr_s = np.gradient(r_s, axis=1) / dt
    theta_s_u = np.unwrap(theta_s, axis=1)
    dtheta_s = np.gradient(theta_s_u, axis=1) / dt

    return dr_s, dtheta_s, r_s, theta_s


# =========================
# Bin / average in (r, theta)
# =========================

def bin_average_polar(r, theta, ur, ut, n_r_bins=20, n_theta_bins=36):
    """
    Bin and average polar velocities (ur, ut) in (r, theta).

    r, theta, ur, ut: 1D arrays of equal length (flattened samples).
    Returns:
      r_centers, theta_centers, ur_grid, ut_grid, counts
        r_centers: (n_r_bins,)
        theta_centers: (n_theta_bins,)
        ur_grid, ut_grid, counts: (n_r_bins, n_theta_bins)
    """
    # ensure theta in [0, 2pi)
    theta_mod = np.mod(theta, 2 * np.pi)

    # bin edges
    r_min, r_max = np.min(r), np.max(r)
    r_edges = np.linspace(r_min, r_max, n_r_bins + 1)
    theta_edges = np.linspace(0, 2 * np.pi, n_theta_bins + 1)

    # bin indices
    r_idx = np.digitize(r, r_edges) - 1
    t_idx = np.digitize(theta_mod, theta_edges) - 1

    # clip to valid range
    r_idx = np.clip(r_idx, 0, n_r_bins - 1)
    t_idx = np.clip(t_idx, 0, n_theta_bins - 1)

    ur_grid = np.zeros((n_r_bins, n_theta_bins))
    ut_grid = np.zeros((n_r_bins, n_theta_bins))
    counts = np.zeros((n_r_bins, n_theta_bins), dtype=int)

    # accumulate sums and counts
    for i in range(r.size):
        ri = r_idx[i]
        ti = t_idx[i]
        ur_grid[ri, ti] += ur[i]
        ut_grid[ri, ti] += ut[i]
        counts[ri, ti] += 1

    # avoid division by zero
    mask = counts > 0
    ur_grid[mask] /= counts[mask]
    ut_grid[mask] /= counts[mask]

    # bin centers
    r_centers = 0.5 * (r_edges[:-1] + r_edges[1:])
    theta_centers = 0.5 * (theta_edges[:-1] + theta_edges[1:])

    return r_centers, theta_centers, ur_grid, ut_grid, counts


def smooth_binned_polar(ur_grid, ut_grid, counts, sigma_r_bins=1.0, sigma_theta_bins=1.0):
    """
    Optional Gaussian smoothing in (r-bin, theta-bin) index space,
    weighted by counts so empty bins don't dominate.

    ur_grid, ut_grid, counts: (n_r_bins, n_theta_bins)
    """
    if sigma_r_bins <= 0 and sigma_theta_bins <= 0:
        return ur_grid, ut_grid

    from scipy.ndimage import gaussian_filter

    sigma = (sigma_r_bins, sigma_theta_bins)

    # weight by counts to reduce influence of empty / low-sample bins
    w_ur = ur_grid * counts
    w_ut = ut_grid * counts

    w_ur_s = gaussian_filter(w_ur, sigma=sigma, mode='nearest')
    w_ut_s = gaussian_filter(w_ut, sigma=sigma, mode='nearest')
    counts_s = gaussian_filter(counts.astype(float), sigma=sigma, mode='nearest')

    mask = counts_s > 1e-6
    ur_s = np.zeros_like(ur_grid)
    ut_s = np.zeros_like(ut_grid)
    ur_s[mask] = w_ur_s[mask] / counts_s[mask]
    ut_s[mask] = w_ut_s[mask] / counts_s[mask]

    return ur_s, ut_s


# =========================
# Polar <-> Cartesian velocities
# =========================

def polvel_to_cart(ur, ut, theta):
    """
    ur, ut: radial and tangential velocities
    theta: angle
    All broadcastable to same shape.

    Returns:
      u, v
    """
    u = ur * np.cos(theta) - ut * np.sin(theta)
    v = ur * np.sin(theta) + ut * np.cos(theta)
    return u, v


def cartvel_to_polar(u, v, theta):
    """
    Convert (u, v) to polar components (ur, ut) at angle theta.
    """
    ur = u * np.cos(theta) + v * np.sin(theta)
    ut = -u * np.sin(theta) + v * np.cos(theta)
    return ur, ut


# =========================
# RBF interpolation to Cartesian grid
# =========================

def create_field_rbf(x, y, u, v, grid_size=100, z_lim=5,
                     function='multiquadric', epsilon=None, smooth=0.0):
    """
    x, y, u, v: 1D arrays (flattened) or (n_traj, n_points) arrays.
    """
    x_flat = np.asarray(x).ravel()
    y_flat = np.asarray(y).ravel()
    u_flat = np.asarray(u).ravel()
    v_flat = np.asarray(v).ravel()

    if z_lim == 0:
        x_min, x_max = x_flat.min() - 1, x_flat.max() + 1
        y_min, y_max = y_flat.min() - 1, y_flat.max() + 1
        z_min = min(x_min, y_min)
        z_max = max(x_max, y_max)
    else:
        z_min, z_max = -z_lim, z_lim

    xi, yi = np.meshgrid(
        np.linspace(z_min, z_max, grid_size),
        np.linspace(z_min, z_max, grid_size)
    )

    rbfu = Rbf(x_flat, y_flat, u_flat,
               function=function, epsilon=epsilon, smooth=smooth)
    rbfv = Rbf(x_flat, y_flat, v_flat,
               function=function, epsilon=epsilon, smooth=smooth)

    ui = rbfu(xi, yi)
    vi = rbfv(xi, yi)

    return xi, yi, ui, vi


# =========================
# Plotting
# =========================

def plot_field(xi, yi, ui, vi, ax=None, density=1.0,
               show_cbar=False, add_streamplot=False):
    speed = np.sqrt(ui**2 + vi**2)

    if ax is None:
        fig, ax = plt.subplots(figsize=(5, 5))

    vmin, vmax = np.nanpercentile(speed, [5, 95])
    norm = mpl.colors.Normalize(vmin, vmax)

    heatmap = ax.pcolormesh(
        xi, yi, speed, cmap='coolwarm',
        shading='gouraud', norm=norm
    )

    if add_streamplot:
        ax.streamplot(xi, yi, ui, vi,
                      density=density, color='k', linewidth=0.5)

    if show_cbar:
        plt.colorbar(heatmap, ax=ax, label='speed')

    ax.set_aspect('equal')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    return ax


# =========================
# High-level pipeline
# =========================

def build_binned_polar_mean_field(x, y,
                                  sigma_r_time=1.0,
                                  sigma_t_time=10.0,
                                  dt=1.0,
                                  n_r_bins=20,
                                  n_theta_bins=36,
                                  sigma_r_bins=0.0,
                                  sigma_theta_bins=0.0,
                                  grid_size=100,
                                  z_lim=5,
                                  rbf_function='multiquadric',
                                  rbf_epsilon=None,
                                  rbf_smooth=0.0):
    """
    Full pipeline:
      1) smooth trajectories in polar along time;
      2) compute instantaneous (ur, ut);
      3) bin + average (ur, ut) in (r, theta);
      4) optional smoothing in bin-space;
      5) reconstruct a mean Cartesian field from binned (ur, ut) using RBF in (x, y).
    """
    # 1) smooth along time in polar
    dr_s, dtheta_s, r_s, theta_s = smooth_polar_time(
        x, y,
        sigma_r_time=sigma_r_time,
        sigma_t_time=sigma_t_time,
        dt=dt
    )

    # instantaneous polar velocities
    ur = dr_s                         # radial velocity
    ut = r_s * dtheta_s               # tangential velocity

    # flatten all samples
    r_flat = r_s.ravel()
    theta_flat = theta_s.ravel()
    ur_flat = ur.ravel()
    ut_flat = ut.ravel()

    # 2) bin + average in (r, theta)
    r_cent, th_cent, ur_grid, ut_grid, counts = bin_average_polar(
        r_flat, theta_flat, ur_flat, ut_flat,
        n_r_bins=n_r_bins,
        n_theta_bins=n_theta_bins
    )

    # 3) optional smoothing in (r-bin, theta-bin)
    ur_grid_s, ut_grid_s = smooth_binned_polar(
        ur_grid, ut_grid, counts,
        sigma_r_bins=sigma_r_bins,
        sigma_theta_bins=sigma_theta_bins
    )

    # 4) create representative (x, y, u, v) samples from binned field
    #    (one point per bin center that has data)
    rr, tt = np.meshgrid(r_cent, th_cent, indexing='ij')  # (n_r_bins, n_theta_bins)
    rr_flat = rr.ravel()
    tt_flat = tt.ravel()
    ur_flat_b = ur_grid_s.ravel()
    ut_flat_b = ut_grid_s.ravel()
    count_flat = counts.ravel()

    # keep only bins with data
    mask = count_flat > 0
    rr_flat = rr_flat[mask]
    tt_flat = tt_flat[mask]
    ur_flat_b = ur_flat_b[mask]
    ut_flat_b = ut_flat_b[mask]

    # polar -> cartesian positions and velocities
    x_b = rr_flat * np.cos(tt_flat)
    y_b = rr_flat * np.sin(tt_flat)
    u_b, v_b = polvel_to_cart(ur_flat_b, ut_flat_b, tt_flat)

    # 5) interpolate this mean field on Cartesian grid with RBF
    xi, yi, ui, vi = create_field_rbf(
        x_b, y_b, u_b, v_b,
        grid_size=grid_size,
        z_lim=z_lim,
        function=rbf_function,
        epsilon=rbf_epsilon,
        smooth=rbf_smooth
    )

    return xi, yi, ui, vi, (r_cent, th_cent, ur_grid_s, ut_grid_s, counts)
#+end_src

#+RESULTS:

#+begin_src ipython
    xi, yi, ui, vi, _ = build_binned_polar_mean_field(
        x_coor, y_coor,
        sigma_r_time=1.0,
        sigma_t_time=1.0,
        dt=1.0,
        n_r_bins=32,
        n_theta_bins=32,
        sigma_r_bins=1.0,      # smooth across neighboring r-bins
        sigma_theta_bins=0.5,  # smooth across neighboring theta-bins
        grid_size=32,
        z_lim=15,
        rbf_function='multiquadric',
        rbf_epsilon=None,
        rbf_smooth=0.0
    )

    ax = plot_field(xi, yi, ui, vi, add_streamplot=True, show_cbar=False)
    plt.show()

#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_62.png]]


#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy.ndimage import gaussian_filter1d, gaussian_filter
from scipy.interpolate import Rbf

def create_field_rbf(
    x, y, u, v,
    grid_size=100,
    z_lim=5,
    method='multiquadric',
    epsilon=None,
    smooth=0.0
):
    """
    Interpolate velocity field to a regular grid using RBFs.

    Inputs:
      x, y, u, v: (n_traj, n_points) or (n_samples,) arrays
      grid_size: number of grid points per dimension
      z_lim: if 0, use bounding box of data; otherwise [-z_lim, z_lim]^2
      function: RBF type ('multiquadric', 'inverse', 'gaussian', 'linear', etc.)
      epsilon: shape parameter; if None, Rbf chooses something heuristic
      smooth: smoothing parameter passed to Rbf (regularization)

    Returns:
      xi, yi, ui, vi: all (grid_size, grid_size) arrays
    """
    x_flat = x.flatten()
    y_flat = y.flatten()
    u_flat = u.flatten()
    v_flat = v.flatten()

    # Domain limits
    if z_lim == 0:
        x_min, x_max = x_flat.min() - 1, x_flat.max() + 1
        y_min, y_max = y_flat.min() - 1, y_flat.max() + 1
        z_min = min(x_min, y_min)
        z_max = max(x_max, y_max)
    else:
        z_min, z_max = -z_lim, z_lim

    xi, yi = np.meshgrid(np.linspace(z_min, z_max, grid_size),
                         np.linspace(z_min, z_max, grid_size))

    # One RBF for u, one for v
    rbfu = Rbf(
        x_flat, y_flat, u_flat,
        function=method,
        epsilon=epsilon,
        smooth=smooth
    )
    rbfv = Rbf(
        x_flat, y_flat, v_flat,
        function=method,
        epsilon=epsilon,
        smooth=smooth
    )

    ui = rbfu(xi, yi)
    vi = rbfv(xi, yi)

    return xi, yi, ui, vi
#+end_src

#+RESULTS:

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy.ndimage import gaussian_filter1d, gaussian_filter
from scipy.interpolate import LinearNDInterpolator, NearestNDInterpolator


# =========================
# Polar velocities
# =========================

def polar_velocities(x, y, sigma_r=1, sigma_t=10):
    """
    x, y: arrays of shape (n_traj, n_points)
    sigma_r, sigma_t: gaussian smoothing in time (in points) for r, theta

    Returns:
      dr_s, dtheta_s: (n_traj, n_points): smoothed radial and angular velocities
      r_s, theta_s: smoothed positions in polar coords
    """
    # Polar coords
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    # Unwrap angles along time axis
    theta_u = np.unwrap(theta, axis=1)

    # Smooth positions along time only
    # r_s = gaussian_filter1d(r, sigma=sigma_r, axis=1, mode='nearest')
    # theta_s = gaussian_filter1d(theta_u, sigma=sigma_t, axis=1, mode='nearest')

    # r, theta: (n_traj, n_points)
    r_s = gaussian_filter(r, sigma=(sigma_t, 1), mode='nearest')
    theta_s = gaussian_filter(theta_u, sigma=(sigma_t, 1), mode='nearest')

    # Derivatives along time
    dr_s = np.gradient(r_s, axis=1)
    dtheta_s = np.gradient(theta_s, axis=1)

    return dr_s, dtheta_s, r_s, theta_s


# =========================
# Polar to Cartesian
# =========================

def pol2cart(dr, dtheta, r, theta):
    """
    Converts smoothed polar velocities to Cartesian velocities.
    All arrays shape: (n_traj, n_points)
    """
    u = dr * np.cos(theta) - r * dtheta * np.sin(theta)
    v = dr * np.sin(theta) + r * dtheta * np.cos(theta)
    return u, v


# =========================
# Interpolation to grid
# =========================

def create_field(x, y, u, v, grid_size=100, method='linear', z_lim=5):
    """
    Interpolate velocity field to a regular grid.

    Inputs:
      x, y, u, v: (n_traj, n_points) or (n_samples,) arrays
      grid_size: number of grid points per dimension
      method: 'linear' (via LinearNDInterpolator) or any method supported
              by griddata ('linear', 'nearest', 'cubic') if not 'linear' here.
      z_lim: if 0, use bounding box of data; otherwise domain = [-z_lim, z_lim]^2

    Returns:
      xi, yi, ui, vi: all (grid_size, grid_size) arrays
    """
    x_flat = x.flatten()
    y_flat = y.flatten()
    u_flat = u.flatten()
    v_flat = v.flatten()

    # Domain limits
    if z_lim == 0:
        x_min, x_max = x_flat.min() - 1, x_flat.max() + 1
        y_min, y_max = y_flat.min() - 1, y_flat.max() + 1
        z_min = min(x_min, y_min)
        z_max = max(x_max, y_max)
    else:
        z_min, z_max = -z_lim, z_lim

    xi, yi = np.meshgrid(np.linspace(z_min, z_max, grid_size),
                         np.linspace(z_min, z_max, grid_size))

    # Interpolation
    if method == 'linear':
        # Use LinearNDInterpolator + NearestNDInterpolator fallback
        pts = np.column_stack((x_flat, y_flat))
        lin_u = LinearNDInterpolator(pts, u_flat)
        lin_v = LinearNDInterpolator(pts, v_flat)

        ui = lin_u(xi, yi)
        vi = lin_v(xi, yi)

        mask = np.isnan(ui)
        if np.any(mask):
            near_u = NearestNDInterpolator(pts, u_flat)
            near_v = NearestNDInterpolator(pts, v_flat)
            ui[mask] = near_u(xi[mask], yi[mask])
            vi[mask] = near_v(xi[mask], yi[mask])
    else:
        from scipy.interpolate import griddata
        ui = griddata((x_flat, y_flat), u_flat, (xi, yi),
                      method=method, fill_value=np.nan)
        vi = griddata((x_flat, y_flat), v_flat, (xi, yi),
                      method=method, fill_value=np.nan)

        mask = np.isnan(ui)
        if np.any(mask):
            ui[mask] = griddata((x_flat, y_flat), u_flat, (xi, yi),
                                method='nearest')[mask]
            vi[mask] = griddata((x_flat, y_flat), v_flat, (xi, yi),
                                method='nearest')[mask]

    return xi, yi, ui, vi


# =========================
# Optional spatial smoothing on grid
# =========================

def smooth_field(ui, vi, sigma=1.0):
    """
    Apply Gaussian smoothing to the interpolated field in (x, y).
    ui, vi: (grid_size, grid_size)
    """
    ui_s = gaussian_filter(ui, sigma=sigma)
    vi_s = gaussian_filter(vi, sigma=sigma)
    return ui_s, vi_s


# =========================
# Plotting
# =========================

def plot_field(xi, yi, ui, vi, ax=None, density=1.0, show_cbar=False,
               add_streamplot=False):
    """
    Plot the speed magnitude as a colormap, optionally with streamlines.
    """
    speed = np.sqrt(ui**2 + vi**2)

    if ax is None:
        fig, ax = plt.subplots(figsize=(5, 5))

    # Normalize for coloring
    vmin, vmax = np.nanpercentile(speed, [5, 95])
    norm = mpl.colors.Normalize(vmin, vmax)

    heatmap = ax.pcolormesh(xi, yi, speed, cmap='coolwarm',
                            shading='gouraud', norm=norm)

    if add_streamplot:
        ax.streamplot(xi, yi, ui, vi, density=density,
                      color='k', linewidth=0.5)

    if show_cbar:
        plt.colorbar(heatmap, ax=ax, label='speed')

    ax.set_aspect('equal')
    ax.set_xlabel('x')
    ax.set_ylabel('y')

    return ax
#+end_src

#+RESULTS:

*** smooth r theta

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy.ndimage import gaussian_filter, gaussian_filter1d
from scipy.interpolate import Rbf


# =========================
# Basic polar conversion
# =========================

def cart2polar(x, y):
    """
    x, y: (n_traj, n_points)
    Returns:
      r, theta (r>=0, theta in [-pi, pi])
    """
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)
    return r, theta


# =========================
# Circular smoothing in theta
# =========================

def smooth_theta_circular(theta, sigma_traj=0.0, sigma_time=1.0):
    """
    Smooth theta across trajectories and time in a circular, wrap-aware way.

    theta: (n_traj, n_points), in radians ([-pi, pi] or any range)
    sigma_traj: std dev of Gaussian along trajectory axis (axis=0)
    sigma_time: std dev of Gaussian along time axis (axis=1)

    Returns:
      theta_s: same shape as theta, smoothed but still in [-pi, pi] range
    """
    # Represent angles on the unit circle
    c = np.cos(theta)
    s = np.sin(theta)

    # Smooth c and s with ordinary Gaussian (no special wrap handling needed)
    sigma = (sigma_traj, sigma_time)
    c_s = gaussian_filter(c, sigma=sigma, mode='nearest')
    s_s = gaussian_filter(s, sigma=sigma, mode='nearest')

    # Re-normalize to unit circle to avoid magnitude shrinkage
    mag = np.sqrt(c_s**2 + s_s**2) + 1e-5
    c_s /= mag
    s_s /= mag

    # Back to angles
    theta_s = np.arctan2(s_s, c_s)
    return theta_s


# =========================
# Polar velocities with cross-trajectory + time smoothing
# =========================

def polar_velocities_cross_smooth(
    x, y,
    sigma_r_traj=0.0, sigma_r_time=1.0,
    sigma_t_traj=0.0, sigma_t_time=1.0,
    dt=1.0
):
    """
    Smooth in polar coordinates across trajectories AND time.

    x, y: (n_traj, n_points)

    sigma_r_traj: Gaussian sigma along trajectory axis for radius r
    sigma_r_time: Gaussian sigma along time axis for radius r
    sigma_t_traj: Gaussian sigma along trajectory axis for angle theta
    sigma_t_time: Gaussian sigma along time axis for angle theta

    dt: time step between successive points (for velocity units)

    Returns:
      dr_s, dtheta_s: smoothed radial and angular velocities (n_traj, n_points)
      r_s, theta_s: smoothed polar positions (n_traj, n_points)
    """
    # Convert to polar
    r, theta = cart2polar(x, y)

    # Smooth r in (trajectory, time) index space
    sigma_r = (sigma_r_traj, sigma_r_time)
    r_s = gaussian_filter(r, sigma=sigma_r, mode='nearest')

    # Smooth theta circularly in (trajectory, time)
    # theta_s = smooth_theta_circular(
    #     theta,
    #     sigma_traj=sigma_t_traj,
    #     sigma_time=sigma_t_time
    # )
    theta_s = theta
    # Velocities from smoothed positions
    dr_s = np.gradient(r_s, axis=1) / dt

    # unwrap smoothed theta along time before differentiating
    theta_s_u = np.unwrap(theta_s, axis=1)
    dtheta_s = np.gradient(theta_s_u, axis=1) / dt

    return dr_s, dtheta_s, r_s, theta_s


# =========================
# Polar -> Cartesian velocities
# =========================

def pol2cart(dr, dtheta, r, theta):
    """
    Convert polar velocities to Cartesian.

    dr, dtheta, r, theta: (n_traj, n_points)
    """
    u = dr * np.cos(theta) - r * dtheta * np.sin(theta)
    v = dr * np.sin(theta) + r * dtheta * np.cos(theta)
    return u, v


# =========================
# RBF interpolation to grid
# =========================

def create_field_rbf(
    x, y, u, v,
    grid_size=100,
    z_lim=5,
    function='multiquadric',
    epsilon=None,
    smooth=0.0
):
    """
    Interpolate velocity field to a regular grid using RBFs.

    x, y, u, v: (n_traj, n_points) or (n_samples,) arrays.
    grid_size: number of grid points per dimension.
    z_lim:
      - if 0: use bounding box of data (expanded by 1 unit).
      - else: domain is square [-z_lim, z_lim] x [-z_lim, z_lim].
    function: RBF type ('multiquadric', 'inverse', 'gaussian', 'linear', etc.).
    epsilon: shape parameter; if None, Rbf chooses a heuristic.
    smooth: regularization parameter; >0 for smoother, less exact fit.

    Returns:
      xi, yi, ui, vi: all (grid_size, grid_size) arrays.
    """
    x_flat = x.flatten()
    y_flat = y.flatten()
    u_flat = u.flatten()
    v_flat = v.flatten()

    # Define spatial domain
    if z_lim == 0:
        x_min, x_max = x_flat.min() - 1, x_flat.max() + 1
        y_min, y_max = y_flat.min() - 1, y_flat.max() + 1
        z_min = min(x_min, y_min)
        z_max = max(x_max, y_max)
    else:
        z_min, z_max = -z_lim, z_lim

    xi, yi = np.meshgrid(
        np.linspace(z_min, z_max, grid_size),
        np.linspace(z_min, z_max, grid_size)
    )

    # RBF for u and v
    rbfu = Rbf(
        x_flat, y_flat, u_flat,
        function=function,
        epsilon=epsilon,
        smooth=smooth
    )
    rbfv = Rbf(
        x_flat, y_flat, v_flat,
        function=function,
        epsilon=epsilon,
        smooth=smooth
    )

    ui = rbfu(xi, yi)
    vi = rbfv(xi, yi)

    return xi, yi, ui, vi


# =========================
# Optional spatial smoothing on grid
# =========================

def smooth_field(ui, vi, sigma=1.0):
    """
    Apply Gaussian smoothing to interpolated field on the grid.

    ui, vi: (grid_size, grid_size)
    """
    ui_s = gaussian_filter(ui, sigma=sigma)
    vi_s = gaussian_filter(vi, sigma=sigma)
    return ui_s, vi_s


# =========================
# Plotting
# =========================

def plot_field(
    xi, yi, ui, vi,
    ax=None,
    density=1.0,
    show_cbar=False,
    add_streamplot=False
):
    """
    Plot speed magnitude as colormap and optionally streamlines.

    xi, yi, ui, vi: (grid_size, grid_size)
    """
    speed = np.sqrt(ui**2 + vi**2)

    if ax is None:
        fig, ax = plt.subplots(figsize=(5, 5))

    vmin, vmax = np.nanpercentile(speed, [5, 95])
    norm = mpl.colors.Normalize(vmin, vmax)

    heatmap = ax.pcolormesh(
        xi, yi, speed,
        cmap='coolwarm',
        shading='gouraud',
        norm=norm
    )

    if add_streamplot:
        ax.streamplot(
            xi, yi, ui, vi,
            density=density,
            color='k',
            linewidth=0.5
        )

    if show_cbar:
        plt.colorbar(heatmap, ax=ax, label='speed')

    ax.set_aspect('equal')
    ax.set_xlabel('x')
    ax.set_ylabel('y')

    return ax


# =========================
# Example usage sketch
# =========================
#+end_src

#+RESULTS:

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy.ndimage import gaussian_filter1d, gaussian_filter
from scipy.interpolate import Rbf


# =========================
# Basic polar conversion
# =========================

def cart2polar(x, y):
    """
    x, y: (n_traj, n_points)
    Returns:
      r, theta (r>=0, theta in [-pi, pi])
    """
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)
    return r, theta


# =========================
# Circular smoothing in time for theta
# =========================

def smooth_theta_time_circular(theta, sigma_time=1.0):
    """
    Smooth theta along time axis only (axis=1) in a circular, wrap-aware way.
    theta: (n_traj, n_points)
    """
    c = np.cos(theta)
    s = np.sin(theta)

    c_s = gaussian_filter1d(c, sigma=sigma_time, axis=1, mode='nearest')
    s_s = gaussian_filter1d(s, sigma=sigma_time, axis=1, mode='nearest')

    mag = np.sqrt(c_s**2 + s_s**2) + 1e-12
    c_s /= mag
    s_s /= mag

    theta_s = np.arctan2(s_s, c_s)
    return theta_s


# =========================
# Polar velocities: smoothing only along time (safe baseline)
# =========================

def polar_velocities_time_smooth(
    x, y,
    sigma_r_time=1.0,
    sigma_t_time=10.0,
    dt=1.0
):
    """
    Smooth in polar coordinates along time only (no cross-trajectory mixing).

    x, y: (n_traj, n_points)

    Returns:
      dr_s, dtheta_s: smoothed radial and angular velocities
      r_s, theta_s: smoothed polar positions
    """
    r, theta = cart2polar(x, y)

    # Smooth r along time
    r_s = gaussian_filter1d(r, sigma=sigma_r_time, axis=1, mode='nearest')

    # Smooth theta along time, circularly
    theta_s = smooth_theta_time_circular(theta, sigma_time=sigma_t_time)

    # Velocities from smoothed positions
    dr_s = np.gradient(r_s, axis=1) / dt

    theta_s_u = np.unwrap(theta_s, axis=1)
    dtheta_s = np.gradient(theta_s_u, axis=1) / dt

    return dr_s, dtheta_s, r_s, theta_s


# =========================
# (Optional) cross-trajectory smoothing in r only
# =========================

def smooth_r_across_trajectories(r_s, sigma_r_traj=0.0):
    """
    Optionally smooth r across trajectories (axis=0) after time smoothing.
    r_s: (n_traj, n_points)
    """
    if sigma_r_traj <= 0:
        return r_s
    return gaussian_filter1d(r_s, sigma=sigma_r_traj, axis=0, mode='nearest')


# =========================
# Polar -> Cartesian velocities
# =========================

def pol2cart(dr, dtheta, r, theta):
    """
    Convert polar velocities to Cartesian.

    dr, dtheta, r, theta: (n_traj, n_points)
    """
    u = dr * np.cos(theta) - r * dtheta * np.sin(theta)
    v = dr * np.sin(theta) + r * dtheta * np.cos(theta)
    return u, v


# =========================
# RBF interpolation to grid
# =========================

def create_field_rbf(
    x, y, u, v,
    grid_size=100,
    z_lim=5,
    function='multiquadric',
    epsilon=None,
    smooth=0.0
):
    """
    Interpolate velocity field to a regular grid using RBFs.

    x, y, u, v: (n_traj, n_points) or (n_samples,) arrays.
    """
    x_flat = x.flatten()
    y_flat = y.flatten()
    u_flat = u.flatten()
    v_flat = v.flatten()

    if z_lim == 0:
        x_min, x_max = x_flat.min() - 1, x_flat.max() + 1
        y_min, y_max = y_flat.min() - 1, y_flat.max() + 1
        z_min = min(x_min, y_min)
        z_max = max(x_max, y_max)
    else:
        z_min, z_max = -z_lim, z_lim

    xi, yi = np.meshgrid(
        np.linspace(z_min, z_max, grid_size),
        np.linspace(z_min, z_max, grid_size)
    )

    rbfu = Rbf(
        x_flat, y_flat, u_flat,
        function=function,
        epsilon=epsilon,
        smooth=smooth
    )
    rbfv = Rbf(
        x_flat, y_flat, v_flat,
        function=function,
        epsilon=epsilon,
        smooth=smooth
    )

    ui = rbfu(xi, yi)
    vi = rbfv(xi, yi)

    return xi, yi, ui, vi


# =========================
# Optional spatial smoothing on grid
# =========================

def smooth_field(ui, vi, sigma=1.0):
    ui_s = gaussian_filter(ui, sigma=sigma)
    vi_s = gaussian_filter(vi, sigma=sigma)
    return ui_s, vi_s


# =========================
# Plotting
# =========================

def plot_field(
    xi, yi, ui, vi,
    ax=None,
    density=1.0,
    show_cbar=False,
    add_streamplot=False
):
    speed = np.sqrt(ui**2 + vi**2)

    if ax is None:
        fig, ax = plt.subplots(figsize=(5, 5))

    vmin, vmax = np.nanpercentile(speed, [5, 95])
    norm = mpl.colors.Normalize(vmin, vmax)

    heatmap = ax.pcolormesh(
        xi, yi, speed,
        cmap='coolwarm',
        shading='gouraud',
        norm=norm
    )

    if add_streamplot:
        ax.streamplot(
            xi, yi, ui, vi,
            density=density,
            color='k',
            linewidth=0.5
        )

    if show_cbar:
        plt.colorbar(heatmap, ax=ax, label='speed')

    ax.set_aspect('equal')
    ax.set_xlabel('x')
    ax.set_ylabel('y')

    return ax


# =========================
# Example usage sketch
# =========================
#+end_src

#+RESULTS:

#+begin_src ipython
    # 1) Safe baseline: polar smoothing in time only
    dr_s, dtheta_s, r_s, theta_s = polar_velocities_time_smooth(
        x_coor, y_coor,
        sigma_r_time=1.0,
        sigma_t_time=1.0,
        dt=1.0
    )

    # 2) (Optional) very mild cross-trajectory smoothing on r only
    r_s = smooth_r_across_trajectories(r_s, sigma_r_traj=1.0)  # start with 0

    # Recompute dr_s if you change r_s:
    dr_s = np.gradient(r_s, axis=1)

    # 3) Convert to Cartesian velocities
    u, v = pol2cart(dr_s, dtheta_s, r_s, theta_s)

    # 4) Interpolate with RBF
    xi, yi, ui, vi = create_field_rbf(
        x_coor, y_coor, u, v,
        grid_size=32,
        z_lim=15,
        function='multiquadric',
        epsilon=None,
        smooth=0.0
    )

    # 5) Plot
    ax = plot_field(x_coor, y_coor, u, v, add_streamplot=False, show_cbar=0)
    # ax = plot_field(xi, yi, ui, vi, add_streamplot=False, show_cbar=0)
    plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_68.png]]


#+begin_src ipython
# Smooth in polar across trajectories and time
dr_s, dtheta_s, r_s, theta_s = polar_velocities_cross_smooth(
    x_coor, y_coor,
    sigma_r_traj=1,  # cross-trajectory smoothing for r
    sigma_r_time=.10,  # temporal smoothing for r
    sigma_t_traj=15,  # cross-trajectory smoothing for theta
    sigma_t_time=.10, # temporal smoothing for theta
    dt=1.0
)

# Convert to Cartesian velocities
u, v = pol2cart(dr_s, dtheta_s, r_s, theta_s)

# Interpolate field using RBF
xi, yi, ui, vi = create_field_rbf(
    x_coor, y_coor, u, v,
    grid_size=32,
    z_lim=15,
    function='multiquadric',
    epsilon=None,
    smooth=0.0
)

# Optional extra smoothing on grid
# ui, vi = smooth_field(ui, vi, sigma=1.0)

# Plot
ax = plot_field(xi, yi, ui, vi, add_streamplot=False, show_cbar=False)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_68.png]]

*** old

#+begin_src ipython
import numpy as np

n_trials = 96
n_time   = 84
grid_size = 15  # 0..14 in each dimension

# Arrays to hold positions: shape (trials, time)
x_coor = np.zeros((n_trials, n_time), dtype=int)
y_coor = np.zeros((n_trials, n_time), dtype=int)

# Define possible moves: up, down, left, right
moves = np.array([
    [ 1,  0],  # right
    [-1,  0],  # left
    [ 0,  1],  # up
    [ 0, -1],  # down
])

# Initialize starting positions randomly on the grid
x_coor[:, 0] = np.random.randint(0, grid_size, size=n_trials)
y_coor[:, 0] = np.random.randint(0, grid_size, size=n_trials)

for t in range(1, n_time):
    # choose a random move for each trial
    step_indices = np.random.randint(0, len(moves), size=n_trials)
    steps = moves[step_indices]  # shape (n_trials, 2)

    # update positions
    x_coor[:, t] = x_coor[:, t-1] + steps[:, 0]
    y_coor[:, t] = y_coor[:, t-1] + steps[:, 1]

    # enforce grid boundaries (reflecting)
    x_coor[:, t] %= grid_size
    y_coor[:, t] %= grid_size
    # x_coor[:, t] = np.clip(x_coor[:, t], 0, grid_size - 1)
    # y_coor[:, t] = np.clip(y_coor[:, t], 0, grid_size - 1)

# x_coor and y_coor are now shape (96, 84) with random walk trajectories
print(x_coor.shape, y_coor.shape)
#+end_src

#+RESULTS:
: (96, 84) (96, 84)

#+begin_src ipython
plt.plot(x_coor.T);
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_71.png]]

#+begin_src ipython
sigma_r=4
sigma_t=15

# 1. Polar smoothing
dr_s, dtheta_s, r_s, theta_s = polar_velocities(x_coor, y_coor, sigma_r=sigma_r, sigma_t=sigma_t)

# 2. Map back to Cartesian velocities
u, v = pol2cart(dr_s, dtheta_s, r_s, theta_s)

# 3. Interpolate to grid
# xi, yi, ui, vi = create_field(x_coor, y_coor, u, v, grid_size=gsize, method='linear', z_lim=z_lim)
xi, yi, ui, vi = create_field_rbf(x_coor, y_coor, u, v, grid_size=gsize, z_lim=z_lim)

# 4. Plot
fig, ax = plt.subplots(figsize=(width, width))
plot_field(xi, yi, ui, vi, ax=ax)
# plot_field(x_coor, y_coor, u, v, ax=ax)

plt.axhline(0, ls='--', color='k')
plt.axvline(0, ls='--', color='k')
plt.xlabel('PC1')
plt.ylabel('PC2')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_72.png]]

#+begin_src ipython
speed_grid = np.sqrt(ui**2 + vi**2)
plt.figure(figsize=(5,5));
plt.imshow(speed_grid, extent=[xi.min(), xi.max(), yi.min(), yi.max()],
           origin='lower', cmap='viridis')

plt.contour(xi, yi, speed_grid, levels=10, colors='k', alpha=0.3);
plt.gca().set_aspect('equal');
plt.xlabel('PC1'); plt.ylabel('PC2')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_73.png]]

#+begin_src ipython
n_bins = 32

r_all  = r_s.flatten()
dr_all = dr_s.flatten()

# Bin by radius
bins = np.linspace(np.nanmin(r_all), np.nanmax(r_all), n_bins)
bin_centers = 0.5*(bins[:-1] + bins[1:])
digitized = np.digitize(r_all, bins)

dr_mean = np.array([np.nanmean(dr_all[digitized == i]) for i in range(1, len(bins))])

plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, gaussian_filter1d(dr_mean, sigma=2), '-')
plt.xlabel("Radius r")
plt.ylabel("dr/dt")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_74.png]]

#+begin_src ipython
u, v = pol2cart(dr_s, dtheta_s, r_s, theta_s)
speed = np.sqrt(u**2 + v**2).flatten()

speed_mean = np.array([np.nanmean(speed[digitized == i]) for i in range(1, len(bins))])

plt.plot(bin_centers, speed_mean, '-')
plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.xlabel("Radius r")
plt.ylabel("mean speed")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_75.png]]

#+begin_src ipython
theta_all  = theta_s.flatten()
dtheta_all = dtheta_s.flatten()

bins = np.linspace(np.nanmin(theta_all), np.nanmax(theta_all), n_bins)
bin_centers = 0.5*(bins[:-1] + bins[1:])
digitized = np.digitize(theta_all, bins)

dtheta_mean = np.array([np.nanmean(dtheta_all[digitized == i])
                    for i in range(1, len(bins))])

plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, gaussian_filter1d(dtheta_mean, 2, mode='wrap'), '-')

plt.xlabel("$\\theta$")
plt.ylabel("d$\\theta$/dt")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_76.png]]

#+begin_src ipython
u, v = pol2cart(dr_s, dtheta_s, r_s, theta_s)
speed = np.sqrt(u**2 + v**2).flatten()

speed_mean = np.array([np.nanmean(speed[digitized == i]) for i in range(1, len(bins))])

plt.plot(bin_centers, gaussian_filter1d(speed_mean, 2, mode='wrap'), '-')
plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.xlabel("$\\theta$")
plt.ylabel("mean speed")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_77.png]]

#+begin_src ipython
from scipy.integrate import odeint

# Build an interpolant of your field
from scipy.interpolate import RegularGridInterpolator

x_axis = xi[0, :]
y_axis = yi[:, 0]
Ui_int = RegularGridInterpolator((y_axis, x_axis), ui)  # note (y,x) if needed
Vi_int = RegularGridInterpolator((y_axis, x_axis), vi)

def vf(z, t):
    x, y = z
    u = Ui_int([[y, x]])[0]
    v = Vi_int([[y, x]])[0]
    return [u, v]

# Pick some initial conditions
inits = [(0., 0.), (-2, 0), (2,0), (0,-2)]
t = np.linspace(0, 5, 1000)

plot_field(xi, yi, ui, vi, density=1.0)
for x0, y0 in inits:
    traj = odeint(vf, [x0, y0], t)
    plt.plot(traj[:,0], traj[:,1], 'k-', alpha=0.7)
plt.gca().set_aspect('equal');
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_78.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

* Single mouse
** Model

#+begin_src ipython
n_splits = 5
n_repeats = 1
n_comp = 3

X_mice, y_mice, w_mice, evr_mice = [], [], [], []

for mouse in options['mice']:
    idx = (y_all.learning == options['learning'])  & (y_all['mouse'] == mouse)

    X_pca = X_all[idx]
    y_pca = y_all[idx]

    valid_neurons = ~np.all(np.isnan(X_pca), axis=(0, 2))  # shape: (n_neurons,)
    # Keep only valid neurons
    X_pca = X_pca[:, valid_neurons, :]

    X_mouse, y_mouse, w_mouse, evr_mouse = cross_val_avg_pca(X_pca, y_pca, n_splits, n_repeats, n_comp, epoch, condition)

    X_mice.append(X_mouse)
    y_mice.append(y_mouse)
    w_mice.append(w_mouse)
    evr_mice.append(evr_mouse)

#+end_src

#+RESULTS:
#+begin_example
100% 5/5 [00:00<00:00, 42.64it/s]
100% 5/5 [00:00<00:00, 14.99it/s]
100% 5/5 [00:00<00:00,  9.89it/s]
100% 5/5 [00:00<00:00,  5.24it/s]
100% 5/5 [00:00<00:00,  8.06it/s]
100% 5/5 [00:00<00:00,  5.56it/s]
100% 5/5 [00:00<00:00, 24.19it/s]
100% 5/5 [00:00<00:00, 13.11it/s]
100% 5/5 [00:00<00:00, 46.27it/s]
#+end_example

#+begin_src ipython
print(X_mice[0].shape, X_mice[1].shape)
print(y_mice[0].shape, y_mice[1].shape)
print(w_mice[0].shape, w_mice[1].shape)
print(evr_mice[0].shape, evr_mice[1].shape)
#+end_src

#+RESULTS:
: (192, 84, 3) (576, 84, 3)
: (192, 16) (576, 16)
: (5, 3, 184) (5, 3, 201)
: (5, 3) (5, 3)

#+begin_src ipython
X_stack = np.vstack(X_mice)
y_single = pd.concat(y_mice)
w_stack = np.concatenate(w_mice, -1)
evr_single = np.stack(evr_mice)
#+end_src

#+RESULTS:

#+begin_src ipython
X_single = np.array(X_stack, dtype=float)
X_single = np.swapaxes(X_single, 1, 2)
w_single = np.mean(w_stack, 0, dtype=float) * 100
print(X_single.shape, y_single.shape, w_single.shape)
#+end_src

#+RESULTS:
: (4032, 3, 84) (4032, 16) (3, 3319)

** Save/Load

#+begin_src ipython
dum = options['epochs'][0] + '_' + options['learning'] + '_laser_%d' % options['laser']
print(dum)
#+end_src

#+RESULTS:
: TEST_Expert_laser_0

#+begin_src ipython
pkl_save(X_single, 'single_traj_' + dum, path="../data/pca/")
pkl_save(y_single, 'single_labels_' + dum, path="../data/pca/")
pkl_save(w_single, 'single_weights_' + dum, path="../data/pca/")
pkl_save(evr_single, 'single_evr_' + dum, path="../data/pca/")
#+end_src

#+RESULTS:
: saving to ../data/pca//single_traj_TEST_Expert_laser_0.pkl
: saving to ../data/pca//single_labels_TEST_Expert_laser_0.pkl
: saving to ../data/pca//single_weights_TEST_Expert_laser_0.pkl
: saving to ../data/pca//single_evr_TEST_Expert_laser_0.pkl

#+begin_src ipython
X_single = pkl_load('single_traj_' + dum, path="../data/pca/")
y_single = pkl_load( 'single_labels_' + dum, path="../data/pca/")
w_single = pkl_load( 'single_weights_' + dum, path="../data/pca/")
evr_single = pkl_load( 'single_evr_' + dum, path="../data/pca/")
#+end_src

#+RESULTS:
: loading from ../data/pca//single_traj_TEST_Expert_laser_0.pkl
: loading from ../data/pca//single_labels_TEST_Expert_laser_0.pkl
: loading from ../data/pca//single_weights_TEST_Expert_laser_0.pkl
: loading from ../data/pca//single_evr_TEST_Expert_laser_0.pkl

** Trajectories

#+begin_src ipython
n_comp = 3
laser = 0
i_mouse=3

idx_mouse = True
if i_mouse !=-1:
    idx_mouse = (y_single.mouse==options['mice'][i_mouse])
#+end_src

#+RESULTS:

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height),)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = ['AC', 'AD', 'BD', 'BC']
xtime = np.linspace(0, 14, 84)

for i in range(4):
    mask = (y_single.odor_pair==i) & (y_single.laser==laser) & idx_mouse
    X_sel = X_single[mask]

    X_avg = np.mean(X_sel, 0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = np.std(X_sel, 0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)

        ax[k].legend(fontsize=12, frameon=0, loc='best')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_86.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = y_single.tasks.unique()
xtime = np.linspace(0, 14, 84)

for i in range(len(pair)):
    mask = (y_single.tasks==y_single.tasks.unique()[i]) & (y_single.laser==laser) & idx_mouse
    X_sel = X_single[mask]

    X_avg = X_sel.mean(0)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=0)

        ax[k].legend(fontsize=12, frameon=0, loc='best')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_87.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8", "#984ea3", "#4daf4a", "#ffae19"]

pair = ['A', 'B']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_single.sample_odor.values==i) & (y_single.laser==laser) & idx_mouse
    X_sel = X_single[mask]          # Subselect rows
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_88.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8",  "#ffae19"]

pair = ['unpair', 'pair']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_single.pair==i) & (y_single.laser==laser) & idx_mouse
    X_sel = X_single[mask]          # Subselect rows
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_89.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8", "#4daf4a"]

pair = ['nolick', 'lick']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_single.choice==i) & (y_single.laser==laser) & idx_mouse
    X_sel = X_single[mask]          # Subselect rows
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_90.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ["#377eb8", "#4daf4a"]

pair = ['C', 'D']
xtime = np.linspace(0, 14, 84)

for i in range(2):
    mask = (y_single.test_odor==i) & (y_single.laser==0) & idx_mouse
    X_sel = X_single[mask]
    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)
        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_91.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=3, figsize=(3*width, height))

pair = ['AC', 'AD', 'BD', 'BC']

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

for i in range(4):
    idx = (y_single.odor_pair==i) & (y_single.laser==laser) & idx_mouse

    X_avg = (X_single[idx].mean(0))[:, :66]

    ax[0].plot(X_avg[0], X_avg[1], color=color[i], label=pair[i])
    ax[0].set_xlabel('PC 1')
    ax[0].set_ylabel('PC 2')

    ax[1].plot(X_avg[0], X_avg[2], color=color[i], label=pair[i])
    ax[1].set_xlabel('PC 1')
    ax[1].set_ylabel('PC 3')

    ax[2].plot(X_avg[1], X_avg[2], color=color[i], label=pair[i])
    ax[2].set_xlabel('PC 2')
    ax[2].set_ylabel('PC 3')

for k in range(3):
    ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_92.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Embeddings
*** spatial filter

#+begin_src ipython
z_lim =5
size = 0.1

import cmocean
cmap=cmocean.cm.phase

theta = np.arctan2(w_single[0], w_single[1]) * 180 / np.pi
idx = np.argsort(theta)

theta_norm = (theta+ 360) % (360)

counts, bins, patches = plt.hist(theta_norm, bins='auto', range=(0, 360), density=1)

bin_centers = 0.5*(bins[:-1] + bins[1:])
colors = [cmap(center/(360)) for center in bin_centers]

for patch, color in zip(patches, colors):
    patch.set_facecolor(color)

plt.xlabel('Neuron Loc (°)')
plt.ylabel('Density')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_94.png]]

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d, gaussian_filter1d
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height))

for k in range(n_comp):
    sc = ax[k].scatter(theta[idx], w_single[k][idx], alpha=0.5, c=theta_norm[idx], cmap=cmap)
    ax[k].plot(theta[idx], gaussian_filter1d(w_single[k][idx], int(size*w_single.shape[1]), mode='wrap'), 'k')
    ax[k].axhline(0, ls='--', color='k')
    ax[k].set_ylabel('Weights PC %d' % (k+1))
    ax[k].set_xlabel('Neuron Loc (°)')
    ax[k].set_ylim([-z_lim, z_lim])

ax[-1].set_ylim([-z_lim/2, z_lim/2])
plt.colorbar(sc, ax=ax[-1], label='Angle (°)')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_95.png]]

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d, uniform_filter1d
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, width))

ax[0].scatter(w_single[0][idx], w_single[1][idx], c=theta_norm[idx], cmap=cmap, alpha=0.5)
ax[0].plot(gaussian_filter1d(w_single[0][idx], int(size*w_single.shape[1]), mode='wrap'), gaussian_filter1d(w_single[1][idx], int(size*w_single.shape[1]), mode='wrap'), 'k')

ax[0].set_xlabel('PC 1')
ax[0].set_ylabel('PC 2')

ax[1].scatter(w_single[0][idx], w_single[2][idx], c=theta_norm[idx], cmap=cmap, alpha=0.5)
ax[1].plot(gaussian_filter1d(w_single[0][idx], int(size*w_single.shape[1]), mode='wrap'), gaussian_filter1d(w_single[2][idx], int(size*w_single.shape[1]), mode='wrap'), 'k')
ax[1].set_xlabel('PC 1')
ax[1].set_ylabel('PC 3')

sc = ax[2].scatter(w_single[1][idx], w_single[2][idx], c=theta_norm[idx], cmap=cmap, alpha=0.5)
ax[2].plot(gaussian_filter1d(w_single[1][idx], int(size*w_single.shape[1]), mode='wrap'), gaussian_filter1d(w_single[2][idx], int(size*w_single.shape[1]), mode='wrap'), 'k')
ax[2].set_xlabel('PC 2')
ax[2].set_ylabel('PC 3')

for k in range(3):
    ax[k].set_xlim(-z_lim, z_lim)
    ax[k].set_ylim(-z_lim, z_lim)

plt.colorbar(sc, ax=ax[-1], label='Angle (°)')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_96.png]]

#+begin_src ipython
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

ax.plot(gaussian_filter1d(w_single[0][idx], int(size*w_single.shape[1]), mode='wrap'),
           gaussian_filter1d(w_single[1][idx], int(size*w_single.shape[1]), mode='wrap'),
           gaussian_filter1d(w_single[2][idx], int(size*w_single.shape[1]), mode='wrap'),
           rasterized=1, color='k')


sc = ax.scatter(w_single[0][idx],
                w_single[1][idx],
                w_single[2][idx],
                c=theta_norm[idx], cmap=cmap,
                rasterized=1, alpha=0.5)

ax.tick_params(axis='both', which='major', labelsize=12)  # change both x and y (and z in 3D)
ax.tick_params(axis='z', which='major', labelsize=12)     # for the z-axis specifically

ax.set_xlabel('PC 1', fontsize=12)
ax.set_ylabel('PC 2', fontsize=12)
ax.set_zlabel('PC 3', fontsize=12)

ax.set_xlim([-z_lim, z_lim])
ax.set_ylim([-z_lim, z_lim])
ax.set_zlim([-z_lim/10, z_lim/10])

ax.grid(False)

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_97.png]]

*** theta space

#+begin_src ipython
nbins = 32
theta_bins = np.linspace(0, 360, nbins+1)
theta_digitized = np.digitize(theta_norm, theta_bins) - 1

# For each bin, average w[0], w[1], and w[2]
w_binned = np.zeros((3, nbins))
for i in range(nbins):
    mask = theta_digitized == i
    for j in range(3):
        w_binned[j, i] = np.mean(w_single[j][mask]) if np.any(mask) else np.nan

w_smooth = gaussian_filter1d(w_binned, sigma=3, axis=1, mode='wrap')
#+end_src


#+RESULTS:

#+begin_src ipython
import matplotlib.pyplot as plt
from numpy import deg2rad

bin_centers = 0.5 * (theta_bins[:-1] + theta_bins[1:])
theta_plot = deg2rad(bin_centers)

fig, axs = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height))

for i, ax in enumerate(axs):
    ax.plot(theta_plot * 180 / np.pi, w_smooth[i], lw=2)
    ax.axhline(0, ls='--', color='k')
    ax.set_ylabel('Weights PC %d' % (i+1))
    ax.set_xlabel('Neuron Loc (°)')

axs[-1].axvline(45)
axs[-1].axvline(225)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_99.png]]

#+begin_src ipython
import matplotlib.pyplot as plt
from numpy import deg2rad

# Compute bin centers in degrees and radians
bin_centers = 0.5 * (theta_bins[:-1] + theta_bins[1:])
theta_plot = deg2rad(bin_centers)  # for polar plots

fig, axs = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, width), sharey=1)

# PC1 vs PC2
axs[0].plot(w_smooth[0], w_smooth[1], 'k-')
axs[0].set_xlabel('PC 1')
axs[0].set_ylabel('PC 2')

# PC1 vs PC3
axs[1].plot(w_smooth[0], w_smooth[2], 'k-')
axs[1].set_xlabel('PC 1')
axs[1].set_ylabel('PC 3')

# PC2 vs PC3
axs[2].plot(w_smooth[1], w_smooth[2], 'k-')
axs[2].set_xlabel('PC 2')
axs[2].set_ylabel('PC 3')

plt.tight_layout()
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_100.png]]

#+begin_src ipython
import matplotlib.pyplot as plt
from numpy import deg2rad

bin_centers = 0.5 * (theta_bins[:-1] + theta_bins[1:])
theta_plot = deg2rad(bin_centers)

fig, axs = plt.subplots(1, 3, subplot_kw={'polar': True}, figsize=(n_comp*width, width))

for i, ax in enumerate(axs):
    ax.plot(theta_plot, w_smooth[i], lw=2)

plt.tight_layout()
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_101.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Opto

#+begin_src ipython
laser_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15','JawsM18', 'ChRM04', 'ChRM23']
laser_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM18', 'ChRM04', 'ChRM23']
# laser_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15','JawsM18']

traj_mouse = []
for i_mouse, mouse in enumerate(laser_mice):
    idx = (y_single.mouse==mouse) & (y_single.laser==0)
    X_idx = X_single[idx]
    y_idx = y_single[idx]

    traj_ = []
    for i in range(2):
        mask = (y_idx.sample_odor==i)  & (y_idx.tasks=='DPA') # & (y_idx.performance==1) & ((y_idx.tasks=='DPA') | (y_idx.odr_perf==1))
        traj_.append(X_idx[mask].mean(0))

    traj_mouse.append(traj_)

traj_mouse = np.array(traj_mouse)
print(traj_mouse.shape)
#+end_src

#+RESULTS:
: (6, 2, 3, 84)

#+begin_src ipython
traj_opto = []
for i_mouse, mouse in enumerate(laser_mice):
    idx = (y_single.mouse==mouse) & (y_single.laser==1)
    X_idx = X_single[idx]
    y_idx = y_single[idx]

    traj_ = []
    for i in range(2):
        mask = (y_idx.sample_odor==i) & (y_idx.tasks=='DPA') # & (y_idx.performance==1) & ((y_idx.tasks=='DPA') | (y_idx.odr_perf==1))
        traj_.append(X_idx[mask].mean(0))

    traj_opto.append(traj_)

traj_opto = np.array(traj_opto)
print(traj_opto.shape)
#+end_src

#+RESULTS:
: (6, 2, 3, 84)

#+begin_src ipython
fp_mouse = np.nanmean(traj_mouse[..., options['bins_LD']], -1)
fp_opto = np.nanmean(traj_opto[..., options['bins_LD']], -1)

print(fp_mouse.shape)

pc1 = fp_mouse[..., 0]
pc2 = fp_mouse[..., 1]

pc1_opto = fp_opto[..., 0]
pc2_opto = fp_opto[..., 1]
#+end_src

#+RESULTS:
: (6, 2, 3)

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(2*height, height), sharey=1)

for i in range(pc1.shape[0]):
    ax[0].scatter(pc1[i], pc2[i], label=options['mice'][i])
    ax[1].scatter(pc1_opto[i], pc2_opto[i], label=options['mice'][i])

for k in range(2):
    ax[k].axvline(0, color='k')
    ax[k].axhline(0, color='k')

    ax[k].set_xlabel('PC1')
    ax[k].set_ylabel('PC2')
# plt.legend(fontsize=12, frameon=0)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_106.png]]

#+begin_src ipython
perf_off = y_single[y_single['mouse'].isin(laser_mice) & (y_single.laser==0)].groupby(['mouse', 'sample_odor'])['performance'].mean().reset_index()
perf_on = y_single[y_single['mouse'].isin(laser_mice) & (y_single.laser==1)].groupby(['mouse', 'sample_odor'])['performance'].mean().reset_index()

delta_dpa = (perf_on['performance'] - perf_off['performance']).values
print(perf_off.shape, perf_on.shape)
print(delta_dpa)
#+end_src

#+RESULTS:
: (12, 3) (12, 3)
: [ 0.00694444  0.03472222  0.0625      0.02083333  0.          0.
:   0.00694444 -0.04166667  0.01041667  0.09375     0.00694444 -0.00694444]

#+begin_src ipython
perf_off = y_single[y_single['mouse'].isin(laser_mice) & (y_single.laser==0)].groupby(['mouse', 'sample_odor'])['odr_perf'].mean().reset_index()
perf_on = y_single[y_single['mouse'].isin(laser_mice) & (y_single.laser==1)].groupby(['mouse', 'sample_odor'])['odr_perf'].mean().reset_index()

delta_odr = (perf_on['odr_perf'] - perf_off['odr_perf']).values
print(perf_off.shape, perf_on.shape)
print(delta_odr)
#+end_src

#+RESULTS:
: (12, 3) (12, 3)
: [-0.05208333 -0.02083333 -0.015625   -0.0625      0.03125    -0.03125
:  -0.02083333  0.          0.          0.015625   -0.02083333  0.02083333]

#+begin_src ipython
dPC1 = (pc1_opto - pc1).reshape(-1)
dPC2 = (pc2_opto - pc2).reshape(-1)
print(dPC1.shape, dPC2.shape)
#+end_src

#+RESULTS:
: (12,) (12,)

#+begin_src ipython
df = perf_off[['mouse', 'sample_odor']]
df['delta_dpa'] = delta_dpa
df['delta_odr'] = delta_odr

df['mouse'] = pd.Categorical(df['mouse'], categories=laser_mice, ordered=True)
df = df.sort_values('mouse')

df['delta_pc1'] = dPC1
df['delta_pc2'] = dPC2

# df = df[~df['mouse'].str.contains('ChR')]

print(df.head())
#+end_src

#+RESULTS:
:      mouse  sample_odor  delta_dpa  delta_odr  delta_pc1  delta_pc2
: 4  JawsM01          0.0   0.000000   0.031250   2.759770  -0.770054
: 5  JawsM01          1.0   0.000000  -0.031250   1.810811  -0.555614
: 6  JawsM06          0.0   0.006944  -0.020833   0.378300  -0.542618
: 7  JawsM06          1.0  -0.041667   0.000000   0.283066   0.198336
: 8  JawsM12          0.0   0.010417   0.000000   1.421729  -1.607774

#+begin_src ipython
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import pearsonr

fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(2*width, height), sharey=1)

df_ = df.copy()

for i, delta_perf in enumerate(['delta_dpa', 'delta_odr']):
    sns.regplot(data=df_, x='delta_pc1', y=delta_perf, scatter=True,
                fit_reg=True, ci=95, ax=ax[i],
                scatter_kws={'s': 0, 'alpha': 0.7},
                line_kws={'color': 'k', 'lw': 2, 'ls':'--'})

    sns.scatterplot(data=df_, x='delta_pc1', y=delta_perf,
                    hue='mouse', style=None, s=80, alpha=0.8, ax=ax[i],
                    legend=None)

    corr, p_value = pearsonr(df_['delta_pc1'].dropna(), df_[delta_perf].dropna())

    annotation = f"Pearson r = {corr:.2f}\np-value = {p_value:.3f}"
    ax[i].annotate(annotation, xy=(.65, 0.95), xycoords='axes fraction', fontsize=14,
                backgroundcolor='white', verticalalignment='top', horizontalalignment='left',
                bbox=dict(edgecolor=None, facecolor='white', boxstyle='round'))

    ax[i].set_xlabel("$\\Delta$ PC1")
    ax[i].set_ylabel("$\\Delta$ Performance")

ax[0].set_ylabel("$\\Delta$ Performance")
ax[1].set_ylabel("")
# plt.savefig('./figures/bernstein/gng_corr.svg', dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_111.png]]

#+begin_src ipython
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import pearsonr

fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(2*width, height), sharey=1)

df_ = df.copy()

for i, delta_perf in enumerate(['delta_dpa', 'delta_odr']):
    sns.regplot(data=df_, x='delta_pc2', y=delta_perf, scatter=True,
                fit_reg=True, ci=95, ax=ax[i],
                scatter_kws={'s': 0, 'alpha': 0.7},
                line_kws={'color': 'k', 'lw': 2, 'ls':'--'})

    sns.scatterplot(data=df_, x='delta_pc2', y=delta_perf,
                    hue='mouse', style=None, s=80, alpha=0.8, ax=ax[i],
                    legend=None)

    corr, p_value = pearsonr(df_['delta_pc2'].dropna(), df_[delta_perf].dropna())

    annotation = f"Pearson r = {corr:.2f}\np-value = {p_value:.3f}"
    ax[i].annotate(annotation, xy=(.65, 0.95), xycoords='axes fraction', fontsize=14,
                backgroundcolor='white', verticalalignment='top', horizontalalignment='left',
                bbox=dict(edgecolor=None, facecolor='white', boxstyle='round'))

    ax[i].set_xlabel("$\\Delta$ PC2")

ax[0].set_ylabel("$\\Delta$ Performance")
ax[1].set_ylabel("")

# plt.savefig('./figures/bernstein/gng_corr.svg', dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_112.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Flow fields

#+begin_src ipython
n_comp = 3
laser = 0
i_mouse = 3

idx_mouse = True
if i_mouse !=-1:
    idx_mouse = (y_single.mouse==options['mice'][i_mouse])
#+end_src

#+RESULTS:

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d, uniform_filter1d

z_lim=10
gsize=32

sigma_r=1
sigma_t=5

idx = (y_single.tasks=='DPA') & (y_single.laser==0) & (y_single.mouse==options['mice'][i_mouse])

X_delay = X_single[idx].copy()
# X_delay = gaussian_filter1d(X[idx].copy(), sigma=5, mode='nearest')
# X_delay = uniform_filter1d(X[idx].copy(), size=1, mode='nearest')
# X_delay = X_delay[:, :2, options['bins_DELAY']]

x_coor = X_delay[:, 0]
y_coor = X_delay[:, 1]

# 1. Polar smoothing
dr_s, dtheta_s, r, theta = polar_velocities(x_coor, y_coor, sigma_r=sigma_r, sigma_t=sigma_t)

# 2. Map back to Cartesian velocities
u, v = pol2cart(dr_s, dtheta_s, r, theta)

# 3. Interpolate to grid
xi, yi, ui, vi = create_field(x_coor, y_coor, u, v, grid_size=gsize, method='linear', z_lim=z_lim)

# 4. Plot
fig, ax = plt.subplots(figsize=(width, width))
plot_field(xi, yi, ui, vi, ax=ax)
plt.axhline(0, ls='--', color='k')
plt.axvline(0, ls='--', color='k')
plt.xlabel('PC1')
plt.ylabel('PC2')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_115.png]]

#+begin_src ipython
speed_grid = np.sqrt(ui**2 + vi**2)
plt.figure(figsize=(5,5));
plt.imshow(speed_grid, extent=[xi.min(), xi.max(), yi.min(), yi.max()],
           origin='lower', cmap='viridis')

plt.contour(xi, yi, speed_grid, levels=10, colors='k', alpha=0.3);
plt.gca().set_aspect('equal');
plt.xlabel('PC1'); plt.ylabel('PC2')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_116.png]]

#+begin_src ipython
n_bins = 32

r_all  = r.flatten()
dr_all = dr_s.flatten()

# Bin by radius
bins = np.linspace(np.nanmin(r_all), np.nanmax(r_all), n_bins)
bin_centers = 0.5*(bins[:-1] + bins[1:])
digitized = np.digitize(r_all, bins)

dr_mean = np.array([np.nanmean(dr_all[digitized == i]) for i in range(1, len(bins))])

plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, gaussian_filter1d(dr_mean, sigma=2), '-')
plt.xlabel("Radius r")
plt.ylabel("dr/dt")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_117.png]]

#+begin_src ipython
u, v = pol2cart(dr_s, dtheta_s, r, theta)
speed = np.sqrt(u**2 + v**2).flatten()

speed_mean = np.array([np.nanmean(speed[digitized == i]) for i in range(1, len(bins))])

plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, speed_mean, '-')
plt.xlabel("Radius r")
plt.ylabel("mean speed")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_118.png]]

#+begin_src ipython
theta_all  = theta.flatten()
dtheta_all = dtheta_s.flatten()

bins = np.linspace(np.nanmin(theta_all), np.nanmax(theta_all), n_bins)
bin_centers = 0.5*(bins[:-1] + bins[1:])
digitized = np.digitize(theta_all, bins)

dtheta_mean = np.array([np.nanmean(dtheta_all[digitized == i])
                    for i in range(1, len(bins))])

plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, gaussian_filter1d(dtheta_mean, 2, mode='wrap'), '-')
plt.xlabel("$\\theta$")
plt.ylabel("d$\\theta$/dt")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_119.png]]

#+begin_src ipython
u, v = pol2cart(dr_s, dtheta_s, r, theta)
speed = np.sqrt(u**2 + v**2).flatten()

speed_mean = np.array([np.nanmean(speed[digitized == i]) for i in range(1, len(bins))])

plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, gaussian_filter1d(speed_mean, 2, mode='wrap'), '-')
plt.xlabel("$\\theta$")
plt.ylabel("mean speed")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_120.png]]

#+begin_src ipython
from scipy.integrate import odeint

# Build an interpolant of your field
from scipy.interpolate import RegularGridInterpolator

x_axis = xi[0, :]
y_axis = yi[:, 0]
Ui_int = RegularGridInterpolator((y_axis, x_axis), ui)  # note (y,x) if needed
Vi_int = RegularGridInterpolator((y_axis, x_axis), vi)

def vf(z, t):
    x, y = z
    u = Ui_int([[y, x]])[0]
    v = Vi_int([[y, x]])[0]
    return [u, v]

# Pick some initial conditions
inits = [(0., 0.), (-2, 0), (2,0), (0,-2)]
t = np.linspace(0, 50, 1000)

plot_field(xi, yi, ui, vi, density=1.0)
for x0, y0 in inits:
    traj = odeint(vf, [x0, y0], t)
    plt.plot(traj[:,0], traj[:,1], 'k-', alpha=0.7)
plt.gca().set_aspect('equal');
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_121.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

* Energy

#+begin_src ipython
traj_mouse = []
for i_mouse, mouse in enumerate(options['mice']):
    idx = (y.mouse==mouse)
    X_idx = X[idx]
    y_idx = y[idx]

    mask = (y_idx.tasks=='DPA')
    traj_ = X_idx[mask]

    traj_mouse.append(traj_)

traj_mouse = np.array(traj_mouse, dtype=object)
print(traj_mouse.shape)
#+end_src

#+RESULTS:
: (9,)

#+begin_src ipython
from src.attractor.landscape import EnergyLandscape
energy = EnergyLandscape(IF_HMM=0)

num_bins = 360 // 4
window = 2

bins = np.linspace(0, 2*np.pi, num_bins, endpoint=False)
print(bins.shape)
#+end_src

#+RESULTS:
: (90,)

#+begin_src ipython
landscapes = []
for i in range(traj_mouse.shape[0]):
    traj = traj_mouse[i]
    try:
        phi = (np.arctan2(traj[1], traj[0]) - np.pi) % (2* np.pi)
        landscape = energy.fit(phi[:,:options['bins_DELAY'][-1]], bins, window=window)
        # landscape = energy.fit(phi[..., options['bins_DELAY']], bins, window=window)
        landscapes.append(landscape)
        plt.plot(bins[:-1] * 180 / np.pi, landscape, alpha=0.25)
    except:
        pass

plt.plot(bins[:-1] * 180 / np.pi, np.nanmean(landscapes, 0), 'k')
plt.axvline(0)
plt.axvline(180)
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_61.png]]

#+begin_src ipython
angles = bins[:-1]
energies = np.nanmean(landscapes, 0)

# Append first point to end to close the curve
angles_wrapped = np.append(angles, angles[0])
energies_wrapped = np.append(energies, energies[0])

fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
ax.plot(angles_wrapped, energies_wrapped, 'k')
ax.grid(False)
ax.set_yticklabels([])
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_62.png]]


#+begin_src ipython

#+end_src

#+RESULTS:

* Speed

#+begin_src ipython
n_comp = 3
laser = 0
i_mouse = -1

idx_mouse = True
if i_mouse !=-1:
    idx_mouse = (y_meta.mouse==options['mice'][i_mouse])
#+end_src

#+RESULTS:

#+begin_src ipython
idx = (y_meta.tasks=='DPA') & (y_meta.laser==0) & idx_mouse
y_ = y_meta[idx]
speed = np.abs(np.diff(X_meta[idx], axis=-1))
print(speed.shape)
#+end_src

#+RESULTS:
: (800, 3, 83)

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=n_comp, figsize=(n_comp*width, height), sharey=1)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = ['AC', 'AD', 'BD', 'BC']
xtime = np.linspace(0, 14, 83)

for i in range(4):
    mask = (y_.odor_pair==i)
    X_sel = speed[mask]          # Subselect rows
    # X_sel = np.abs(np.diff(X_sel, axis=-1))

    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    for k in range(n_comp):
        y_avg = X_avg[k]
        y_sem = X_sem[k]
        ax[k].plot(xtime, y_avg, color=color[i], label=pair[i])
        ax[k].fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[i], alpha=0.2)
        ax[k].axhline(0, ls='--', color='k')
        ax[k].set_xlabel('Time')
        ax[k].set_ylabel('PC %d' % (k+1))
        add_vlines(ax[k], if_dpa=1)

        ax[k].legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_129.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(width, height), sharey=1)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

xtime = np.linspace(0, 14, 83)

X_avg = gaussian_filter1d(speed.mean(0), sigma=2)    # Mean over trials/samples, shape: (n_comp, n_time)
X_sem = speed.std(0) / np.sqrt(speed.shape[0])  # SEM

for k in range(n_comp):
    y_avg = X_avg[k]
    y_sem = X_sem[k]
    ax.plot(xtime, y_avg, color=color[k], label='PC %d' %k)
    ax.fill_between(xtime, y_avg-y_sem, y_avg+y_sem, color=color[k], alpha=0.2)
    ax.axhline(0, ls='--', color='k')
    ax.set_xlabel('Time')
    ax.set_ylabel('Speed')
    add_vlines(ax, if_dpa=0)

    ax.legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_130.png]]

#+begin_src ipython
x = X_meta[idx, 0, :]  # shape (trials, time)
y = X_meta[idx, 1, :]

# Differences along time axis
dx = np.diff(x, axis=-1)
dy = np.diff(y, axis=-1)

# Paired x, y for time intervals
x_mid = x[:, :-1]
y_mid = y[:, :-1]

# Radial distance from origin
radius = np.sqrt(x_mid**2 + y_mid**2)

# Radial speed (project velocity onto unit vector from origin)
radial_speed = (x_mid * dx + y_mid * dy) / radius

# Angle for each time point
angles = np.arctan2(y, x)

angles_unwrapped = np.unwrap(angles, axis=-1)
angular_speed = np.diff(angles_unwrapped, axis=-1)  # in radians per time step
print(radial_speed.shape, angular_speed.shape)
#+end_src

#+RESULTS:
: (800, 83) (800, 83)

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(width, height), sharey=1)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = ['AC', 'AD', 'BD', 'BC']
xtime = np.linspace(0, 14, 83)

for i in range(4):
    mask = (y_.odor_pair==i)
    X_sel = radial_speed[mask]

    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    ax.plot(xtime, gaussian_filter1d(X_avg, sigma=1), color=color[i], label=pair[i])
    # ax.fill_between(xtime, X_avg-X_sem, X_avg+X_sem, color=color[i], alpha=0.2)
    ax.axhline(0, ls='--', color='k')
    ax.set_xlabel('Time')
    ax.set_ylabel('Radial')
    add_vlines(ax, if_dpa=1)

    ax.legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_132.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(width, height), sharey=1)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = ['AC', 'AD', 'BD', 'BC']
xtime = np.linspace(0, 14, 83)

for i in range(4):
    mask = (y_.odor_pair==i)
    X_sel = angular_speed[mask]

    X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
    X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

    ax.plot(xtime, gaussian_filter1d(X_avg, sigma=5), color=color[i], label=pair[i])
    # ax.fill_between(xtime, X_avg-X_sem, X_avg+X_sem, color=color[i], alpha=0.2)
    ax.axhline(0, ls='--', color='k')
    ax.set_xlabel('Time')

    add_vlines(ax, if_dpa=1)

    ax.legend(fontsize=12, frameon=0, loc='best')
ax.set_ylabel('Angular')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_133.png]]

#+begin_src ipython
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(width, height), sharey=1)

color = ['#332288', '#88CCEE', '#117733', '#44AA99']

pair = ['AC', 'AD', 'BD', 'BC']
xtime = np.linspace(0, 14, 83)

X_sel = radial_speed
X_avg = X_sel.mean(0)
X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])

ax.plot(xtime, gaussian_filter1d(X_avg, sigma=1), color=color[0], label='radial')

X_sel = angular_speed
X_avg = X_sel.mean(0)    # Mean over trials/samples, shape: (n_comp, n_time)
X_sem = X_sel.std(0) / np.sqrt(X_sel.shape[0])  # SEM

ax.plot(xtime, gaussian_filter1d(X_avg, sigma=1), color=color[2], label='angular')

# ax.fill_between(xtime, X_avg-X_sem, X_avg+X_sem, color=color[i], alpha=0.2)
ax.axhline(0, ls='--', color='k')
ax.set_xlabel('Time')
ax.set_ylabel('Speed')
add_vlines(ax, if_dpa=1)

ax.legend(fontsize=12, frameon=0, loc='best')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_134.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

* Flow fields

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter

def polar_velocities(x, y, sigma_r=1, sigma_t=10):
    """
    x, y: (n_traj, n_points)
    sigma: gaussian smoothing in time (in points)
    Returns:
      dr_s, dtheta_s: (n_traj, n_points): smoothed radial and angular velocities
      r, theta: positions at each point, for later conversion
    """
    # Polar coords
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    # Derivatives
    dr = np.gradient(r, axis=1)

    # Handle angle wrapping
    dtheta = np.unwrap(theta, axis=1)
    dtheta = np.gradient(dtheta, axis=1)

    # Smoothing
    dr_s = gaussian_filter(dr, sigma=sigma_r)
    dtheta_s = gaussian_filter(dtheta, sigma=sigma_t)

    return dr_s, dtheta_s, r, theta

def pol2cart(dr, dtheta, r, theta):
    """
    Converts smoothed polar velocities to Cartesian velocities.
    All arrays shape: (n_traj, n_points)
    """
    u = dr * np.cos(theta) - r * dtheta * np.sin(theta)
    v = dr * np.sin(theta) + r * dtheta * np.cos(theta)
    return u, v

def create_field(x, y, u, v, grid_size=100, method='linear', z_lim=5):
    """
    Interpolate velocity field to a regular grid.
    Inputs: x,y,u,v all (n_samples,) or (n_traj, n_points) -- flatten them first.
    Returns: xi, yi, ui, vi: all (grid_size, grid_size) arrays.
    """
    x_flat = x.flatten()
    y_flat = y.flatten()
    u_flat = u.flatten()
    v_flat = v.flatten()

    # xi, yi = np.meshgrid(
    #     np.linspace(np.min(x_flat), np.max(x_flat), grid_size),
    #     np.linspace(np.min(y_flat), np.max(y_flat), grid_size),
    # )

    x_min, x_max = np.min(x_flat)-1, np.max(x_flat)+1
    y_min, y_max = np.min(y_flat)-1, np.max(y_flat)+1

    if z_lim is 0:
        z_min = np.min((x_min, y_min))
        z_max = np.min((x_max, y_max))
    else:
        z_min = -z_lim
        z_max = z_lim

    xi, yi = np.meshgrid(np.linspace(z_min, z_max, grid_size),
                         np.linspace(z_min, z_max, grid_size))


    ui = griddata((x_flat, y_flat), u_flat, (xi, yi), method=method, fill_value=np.nan)
    vi = griddata((x_flat, y_flat), v_flat, (xi, yi), method=method, fill_value=np.nan)

    # Fill nans with nearest
    mask = np.isnan(ui)
    if np.any(mask):
        ui[mask] = griddata((x_flat, y_flat), u_flat, (xi, yi), method='nearest')[mask]
        vi[mask] = griddata((x_flat, y_flat), v_flat, (xi, yi), method='nearest')[mask]

    return xi, yi, ui, vi

def plot_field(xi, yi, ui, vi, ax=None, density=1.0, show_cbar=0):
    speed = np.sqrt(ui**2 + vi**2)
    if ax is None:
        fig, ax = plt.subplots(figsize=(5,5))
    # Normalize for coloring
    import matplotlib as mpl
    vmin, vmax = np.nanpercentile(speed, [5, 95])
    norm = mpl.colors.Normalize(vmin, vmax)
    # strm = ax.streamplot(xi, yi, ui, vi, density=density, color=speed, cmap='coolwarm', norm=norm)
    heatmap = ax.pcolormesh(xi, yi, speed, cmap='coolwarm', shading='gouraud', norm=norm)

    if show_cbar:
        plt.colorbar(strm.lines, ax=ax, label='Speed')

    ax.set_aspect('equal')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    return ax
#+end_src

#+RESULTS:

#+begin_src ipython
import numpy as np
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter

def polar_velocities(x, y, sigma_t=1):
    """
    Temporal smoothing of velocities in polar coords.
    x,y: (n_traj, n_points)
    sigma_t: Gaussian smoothing along time (axis=1, in points)
    Returns:
      dr_s, dtheta_s: (n_traj, n_points)
      r, theta: (n_traj, n_points), theta unwrapped
    """
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    # unwrap angle along time axis
    theta_unw = np.unwrap(theta, axis=1)

    # temporal derivatives
    dr = np.gradient(r, axis=1)
    dtheta = np.gradient(theta_unw, axis=1)

    # smooth along time only (axis=1)
    if sigma_t is not None and sigma_t > 0:
        dr_s = gaussian_filter(dr, sigma=(0, sigma_t))
        dtheta_s = gaussian_filter(dtheta, sigma=(0, sigma_t))
    else:
        dr_s, dtheta_s = dr, dtheta

    return dr_s, dtheta_s, r, theta_unw


def build_spatial_polar_field(x, y, dr_s, dtheta_s,
                              nr=100, nth=180,
                              sigma_r=1.0, sigma_theta=3.0):
    """
    Build a *spatial* polar flow field (Vr, Vt) from smoothed
    polar velocities along trajectories, then smooth in (r,θ)
    with θ treated as periodic.

    Inputs:
      x, y:         (n_traj, n_points)
      dr_s, dtheta_s: (n_traj, n_points) from polar_velocities
      nr, nth:      # of radial / angular grid points
      sigma_r:      radial smoothing (in grid cells)
      sigma_theta:  angular smoothing (in grid cells, periodic)

    Returns:
      Rg, Tg:   (nr, nth) radial / angular coordinates
      Vr_s, Vt_s: (nr, nth) smoothed radial / angular velocities
    """
    # Flatten samples in time+trajectory
    x_samp = x.flatten()
    y_samp = y.flatten()
    dr_samp = dr_s.flatten()
    dtheta_samp = dtheta_s.flatten()

    # Convert to polar
    r_samp = np.sqrt(x_samp**2 + y_samp**2)
    theta_samp = np.arctan2(y_samp, x_samp)

    # Build polar grid
    r_max = np.nanmax(r_samp)
    r_grid = np.linspace(0, r_max, nr)
    th_grid = np.linspace(-np.pi, np.pi, nth, endpoint=False)
    Rg, Tg = np.meshgrid(r_grid, th_grid, indexing='ij')

    # Interpolate Vr (dr) and Vt (dtheta) onto polar grid
    Vr = griddata(
        (r_samp, theta_samp),
        dr_samp,
        (Rg, Tg),
        method='linear',
        fill_value=np.nan
    )
    Vt = griddata(
        (r_samp, theta_samp),
        dtheta_samp,
        (Rg, Tg),
        method='linear',
        fill_value=np.nan
    )

    # Optional: fill NaNs by nearest-neighbor before smoothing
    mask = np.isnan(Vr)
    if np.any(mask):
        Vr[mask] = griddata(
            (r_samp, theta_samp),
            dr_samp,
            (Rg, Tg),
            method='nearest'
        )[mask]
        Vt[mask] = griddata(
            (r_samp, theta_samp),
            dtheta_samp,
            (Rg, Tg),
            method='nearest'
        )[mask]

    # --- circular smoothing in θ (periodic) + radial smoothing ---
    # Wrap in θ (concat left, center, right)
    Vr_wrap = np.concatenate([Vr, Vr, Vr], axis=1)
    Vt_wrap = np.concatenate([Vt, Vt, Vt], axis=1)

    # Smooth in (r, θ) on wrapped field
    if (sigma_r is not None and sigma_r > 0) or (sigma_theta is not None and sigma_theta > 0):
        sr = sigma_r if sigma_r is not None else 0.0
        st = sigma_theta if sigma_theta is not None else 0.0
        Vr_wrap = gaussian_filter(Vr_wrap, sigma=(sr, st))
        Vt_wrap = gaussian_filter(Vt_wrap, sigma=(sr, st))

    # Take the central copy to enforce periodic boundary
    mid = Vr.shape[1]
    Vr_s = Vr_wrap[:, mid:2*mid]
    Vt_s = Vt_wrap[:, mid:2*mid]

    return Rg, Tg, Vr_s, Vt_s


def polar_field_to_cartesian(Rg, Tg, Vr, Vt):
    """
    Convert a polar vector field (Vr, Vt) on grid (Rg, Tg) to
    Cartesian components (U, V) and positions (Xg, Yg).
    """
    Xg = Rg * np.cos(Tg)
    Yg = Rg * np.sin(Tg)
    U = Vr * np.cos(Tg) - Rg * Vt * np.sin(Tg)
    V = Vr * np.sin(Tg) + Rg * Vt * np.cos(Tg)
    return Xg, Yg, U, V
#+end_src

#+RESULTS:

#+begin_src ipython
n_comp = 3
i_mouse = 3

print(options['mice'][i_mouse])
print(X.shape, y.shape)
#+end_src

#+RESULTS:
: JawsM15
: (4032, 3, 84) (4032, 16)

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d, uniform_filter1d

z_lim=5
gsize=32

sigma_r=5
sigma_t=30

idx = (y_cv.tasks=='DPA') & (y_cv.laser==0) & (y_cv.mouse==options['mice'][i_mouse])

X_delay = X[idx].copy()
# X_delay = gaussian_filter1d(X[idx].copy(), sigma=5, mode='nearest')
# X_delay = uniform_filter1d(X[idx].copy(), size=1, mode='nearest')
# X_delay = X_delay[:, :2, options['bins_DELAY']]

x_coor = X_delay[:, 0]
y_coor = X_delay[:, 1]

# 1. Polar smoothing
dr_s, dtheta_s, r, theta = polar_velocities(x_coor, y_coor, sigma_r=sigma_r, sigma_t=sigma_t)

# 2. Map back to Cartesian velocities
u, v = pol2cart(dr_s, dtheta_s, r, theta)

# 3. Interpolate to grid
xi, yi, ui, vi = create_field(x_coor, y_coor, u, v, grid_size=gsize, method='linear', z_lim=z_lim)

# 4. Plot
fig, ax = plt.subplots(figsize=(width, width))
plot_field(xi, yi, ui, vi, ax=ax)
plt.axhline(0, ls='--', color='k')
plt.axvline(0, ls='--', color='k')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_78.png]]

#+begin_src ipython
print(x_coor.shape)
plt.plot(x_coor.T);
#+end_src

#+RESULTS:
:RESULTS:
: (96, 84)
[[file:./figures/stratpca/figure_79.png]]
:END:

#+begin_src ipython
speed_grid = np.sqrt(ui**2 + vi**2)
plt.figure(figsize=(5,5));
plt.imshow(speed_grid, extent=[xi.min(), xi.max(), yi.min(), yi.max()],
           origin='lower', cmap='viridis')

plt.contour(xi, yi, speed_grid, levels=10, colors='k', alpha=0.3);
plt.gca().set_aspect('equal');
plt.xlabel('PC1'); plt.ylabel('PC2')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_80.png]]

#+begin_src ipython
n_bins = 32

dr_s, dtheta_s, r, theta = polar_velocities(x_coor, y_coor, sigma_r=sigma_r, sigma_t=sigma_t)

r_all  = r.flatten()
dr_all = dr_s.flatten()

# Bin by radius
bins = np.linspace(np.nanmin(r_all), np.nanmax(r_all), n_bins)
bin_centers = 0.5*(bins[:-1] + bins[1:])
digitized = np.digitize(r_all, bins)

dr_mean = np.array([np.nanmean(dr_all[digitized == i])
                    for i in range(1, len(bins))])

plt.figure()
plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, dr_mean, '-')
plt.xlabel("radius r")
plt.ylabel("dr/dt")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_81.png]]

#+begin_src ipython
u, v = pol2cart(dr_s, dtheta_s, r, theta)
speed = np.sqrt(u**2 + v**2).flatten()

speed_mean = np.array([np.nanmean(speed[digitized == i])
                       for i in range(1, len(bins))])

plt.plot(bin_centers, speed_mean, '-')
plt.xlabel("r")
plt.ylabel("mean speed")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_82.png]]

#+begin_src ipython
r_all  = theta.flatten()
dr_all = dtheta_s.flatten()

bins = np.linspace(np.nanmin(r_all), np.nanmax(r_all), n_bins)
bin_centers = 0.5*(bins[:-1] + bins[1:])
digitized = np.digitize(r_all, bins)

dr_mean = np.array([np.nanmean(dr_all[digitized == i])
                    for i in range(1, len(bins))])

plt.figure()
plt.axhline(0, color='k', linestyle='--', linewidth=1)
plt.plot(bin_centers, dr_mean, '-')
plt.xlabel("$\\theta$")
plt.ylabel("d$\\theta$/dt")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_83.png]]

#+begin_src ipython
u, v = pol2cart(dr_s, dtheta_s, r, theta)
speed = np.sqrt(u**2 + v**2).flatten()

speed_mean = np.array([np.nanmean(speed[digitized == i])
                       for i in range(1, len(bins))])

plt.plot(bin_centers, speed_mean, '-')
plt.xlabel("$\\theta$")
plt.ylabel("mean speed")
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_84.png]]

#+begin_src ipython
from scipy.integrate import odeint

# Build an interpolant of your field
from scipy.interpolate import RegularGridInterpolator

x_axis = xi[0, :]
y_axis = yi[:, 0]
Ui_int = RegularGridInterpolator((y_axis, x_axis), ui)  # note (y,x) if needed
Vi_int = RegularGridInterpolator((y_axis, x_axis), vi)

def vf(z, t):
    x, y = z
    u = Ui_int([[y, x]])[0]
    v = Vi_int([[y, x]])[0]
    return [u, v]

# Pick some initial conditions
inits = [(0., 0.), (-2, 0), (2,0), (0,-2)]
t = np.linspace(0, 50, 1000)

plot_field(xi, yi, ui, vi, density=1.0)
for x0, y0 in inits:
    traj = odeint(vf, [x0, y0], t)
    plt.plot(traj[:,0], traj[:,1], 'k-', alpha=0.7)
plt.gca().set_aspect('equal');
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_84.png]]

#+begin_src ipython
plt.figure(figsize=(6,5))
plt.scatter(theta.flatten(), r.flatten(), s=2, alpha=0.3)
plt.xlabel('theta')
plt.ylabel('r')

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_82.png]]

#+begin_src ipython
plt.figure()
for i in range(min(10, dtheta_s.shape[0])):
    plt.plot(dtheta_s[i], alpha=0.4)
plt.axhline(0, color='k', linestyle='--')
plt.xlabel('time')
plt.ylabel('dtheta/dt')
plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_83.png]]

#+begin_src ipython
idx = (y_cv.tasks=='DPA') & (y_cv.test_odor==0) & (y_cv.laser==0) # & (y_cv.mouse==options['mice'][i_mouse])

X_delay = X[idx].copy()
X_delay = X_delay[:, :2, options['bins_TEST']]

x = X_delay[:,0,::2]
y = X_delay[:,1,::2]

# 1. Polar smoothing
dr_s, dtheta_s, r, theta = polar_velocities(x, y, sigma=10)

# 2. Map back to Cartesian velocities
u, v = pol2cart(dr_s, dtheta_s, r, theta)

# 3. Interpolate to grid
xi, yi, ui, vi = create_field(x, y, u, v, grid_size=32, method='linear', z_lim=10)

# 4. Plot
fig, ax = plt.subplots(figsize=(width, width))
plot_field(xi, yi, ui, vi, ax=ax)

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_86.png]]

#+begin_src ipython
idx = (y_cv.tasks=='DPA') & (y_cv.mouse==options['mice'][i_mouse])

X_delay = X[idx].copy()
X_delay = X_delay[:, :2, options['bins_STIM']]

x = X_delay[:,0,::2]
y = X_delay[:,1,::2]

# 1. Polar smoothing
dr_s, dtheta_s, r, theta = polar_velocities(x, y, sigma=1)

# 2. Map back to Cartesian velocities
u, v = pol2cart(dr_s, dtheta_s, r, theta)

# 3. Interpolate to grid
xi, yi, ui, vi = create_field(x, y, u, v, grid_size=32, method='linear', z_lim=10)

# 4. Plot
fig, ax = plt.subplots(figsize=(width, width))
plot_field(xi, yi, ui, vi, ax=ax)

plt.show()
#+end_src

#+RESULTS:
[[file:./figures/stratpca/figure_87.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
