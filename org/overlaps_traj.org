#+STARTUP: fold
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session sample_overlaps :kernel dual_data :output-dir ./figures/sample_overlaps :file (lc/org-babel-tangle-figure-filename)

get single trial projection on choice axis vs delta perf off on animal by animal

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt

def simulate_diffusion(num_steps, step_size):
    # Initialize the position of the particle at angle 0
    theta = 0.0

    # Record the angular positions over time
    angles = [theta]

    for _ in range(num_steps):
        # Randomly perturb the angle with a step size
        theta += np.random.uniform(-step_size, step_size)

        # Ensure the angle stays within the bounds of 0 to 2*pi
        theta = theta % (2 * np.pi)

        angles.append(theta)

    return angles

def plot_diffusion(angles):
    # Convert angles to x, y coordinates on the unit circle
    x = np.cos(angles)
    y = np.sin(angles)

    plt.figure(figsize=(6, 6))
    plt.plot(x, y, marker='o', markersize=2, linestyle='-')
    plt.xlim(-1.1, 1.1)
    plt.ylim(-1.1, 1.1)
    plt.axhline(0, color='gray', linewidth=0.5)
    plt.axvline(0, color='gray', linewidth=0.5)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('Diffusion on the Unit Circle')
    plt.gca().set_aspect('equal')
    plt.show()

# Parameters
num_steps = 1000
step_size = 0.1

angles = simulate_diffusion(num_steps, step_size)
plot_diffusion(angles)
#+end_src

#+RESULTS:
[[./figures/sample_overlaps/figure_0.png]]

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt

def simulate_diffusion(num_steps, angle_step_size, radius_step_size, min_radius, max_radius):
    # Initialize the position of the particle at angle 0 and initial radius
    theta = 0.0
    radius = (min_radius + max_radius) / 2

    # Record the positions over time
    positions = [(theta, radius)]

    for _ in range(num_steps):
        # Randomly perturb the angle
        theta += np.random.uniform(-angle_step_size, angle_step_size)
        # Ensure the angle stays within [0, 2*pi]
        theta = theta % (2 * np.pi)

        # Randomly perturb the radius
        radius += np.random.uniform(-radius_step_size, radius_step_size)
        # Ensure the radius stays within [min_radius, max_radius]
        radius = np.clip(radius, min_radius, max_radius)

        positions.append((theta, radius))

    return positions

def plot_diffusion(positions):
    # Convert positions to x, y coordinates
    x = [r * np.cos(theta) for theta, r in positions]
    y = [r * np.sin(theta) for theta, r in positions]

    plt.figure(figsize=(6, 6))
    plt.plot(x, y, marker='o', markersize=10, linestyle='-')
    plt.xlim(-max_radius-0.1, max_radius+0.1)
    plt.ylim(-max_radius-0.1, max_radius+0.1)
    plt.axhline(0, color='gray', linewidth=0.5)
    plt.axvline(0, color='gray', linewidth=0.5)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('Diffusion Between Two Radii')
    plt.gca().set_aspect('equal')
    plt.gca().add_patch(plt.Circle((0, 0), max_radius, color='b', fill=False, linestyle='--'))
    plt.gca().add_patch(plt.Circle((0, 0), min_radius, color='r', fill=False, linestyle='--'))
    plt.show()

# Parameters
num_steps = 100
angle_step_size = .1
radius_step_size = 0.1
min_radius = 0.2
max_radius = 1.2

positions = simulate_diffusion(num_steps, angle_step_size, radius_step_size, min_radius, max_radius)
plot_diffusion(positions)
#+end_src

#+RESULTS:
[[./figures/sample_overlaps/figure_1.png]]

#+begin_src ipython
import numpy as np
import matplotlib.pyplot as plt

def simulate_diffusion(num_steps, angle_step_size, radius_step_size, min_radius, max_radius):
    # Convert starting x, y coordinates to polar coordinates
    theta = np.pi / 2  # Corresponds to (x, y) = (0, 1) on the unit circle
    radius = 1.0  # Starting on the unit circle

    # Record the positions over time
    positions = [(theta, radius)]

    for _ in range(num_steps):
        # Randomly perturb the angle
        theta += np.random.uniform(-angle_step_size, angle_step_size)
        # Ensure the angle stays within [0, 2*pi]
        theta = theta % (2 * np.pi)

        # Randomly perturb the radius
        radius += np.random.uniform(-radius_step_size, radius_step_size)
        # Ensure the radius stays within [min_radius, max_radius]
        radius = np.clip(radius, min_radius, max_radius)

        positions.append((theta, radius))

    return positions

def plot_diffusion(positions, min_radius, max_radius):
    # Convert positions to x, y coordinates
    x = [r * np.cos(theta) for theta, r in positions]
    y = [r * np.sin(theta) for theta, r in positions]

    plt.figure(figsize=(6, 6))
    plt.plot(x, y, marker='o', markersize=2, linestyle='-')
    plt.xlim(-max_radius-0.1, max_radius+0.1)
    plt.ylim(-max_radius-0.1, max_radius+0.1)
    plt.axhline(0, color='gray', linewidth=0.5)
    plt.axvline(0, color='gray', linewidth=0.5)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('Diffusion Between Two Radii')
    plt.gca().set_aspect('equal')
    plt.gca().add_patch(plt.Circle((0, 0), max_radius, color='b', fill=False, linestyle='--'))
    plt.gca().add_patch(plt.Circle((0, 0), min_radius, color='r', fill=False, linestyle='--'))
    plt.show()

# Parameters
num_steps = 1000
angle_step_size = 0.1
radius_step_size = 0.01
min_radius = 0.8
max_radius = 1.2

positions = simulate_diffusion(num_steps, angle_step_size, radius_step_size, min_radius, max_radius)
plot_diffusion(positions, min_radius, max_radius)
#+end_src

#+RESULTS:
[[./figures/sample_overlaps/figure_2.png]]


* Notebook Settings

#+begin_src ipython
%load_ext autoreload
%autoreload 2
%reload_ext autoreload

%run /home/leon/dual_task/dual_data/notebooks/setup.py
%matplotlib inline
%config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/dual_data/bin/python

* Imports

#+begin_src ipython
  from sklearn.exceptions import ConvergenceWarning
  warnings.filterwarnings("ignore")
  import traceback

  import sys
  sys.path.insert(0, '/home/leon/dual_task/dual_data/')

  import os
  if not sys.warnoptions:
    warnings.simplefilter("ignore")
    os.environ["PYTHONWARNINGS"] = "ignore"

  import pickle as pkl
  import numpy as np
  import matplotlib.pyplot as plt
  import pandas as pd
  import seaborn as sns

  from time import perf_counter

  from sklearn.base import clone
  from sklearn.metrics import make_scorer, roc_auc_score
  from sklearn.preprocessing import StandardScaler, RobustScaler
  from sklearn.model_selection import RepeatedStratifiedKFold, LeaveOneOut, StratifiedKFold

  from src.common.plot_utils import add_vlines, add_vdashed
  from src.common.options import set_options
  from src.stats.bootstrap import my_boots_ci
  from src.common.get_data import get_X_y_days, get_X_y_S1_S2
  from src.preprocess.helpers import avg_epochs
  from src.decode.bump import circcvl
  from src.torch.classificationCV import ClassificationCV
  from src.torch.classify import get_classification
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
def pad_with_nans(array, target_shape):
    result = np.full(target_shape, np.nan)  # Create an array filled with NaNs
    print(result.shape)
    slices = tuple(slice(0, min(dim, target)) for dim, target in zip(array.shape, target_shape))
    result[slices] = array[slices]
    return result
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  import numpy as np

  def safe_roc_auc_score(y_true, y_score):
      y_true = np.asarray(y_true)
      if len(np.unique(y_true)) == 1:
          return 0.5  # return np.nan where the score cannot be calculated
      return roc_auc_score(y_true, y_score)

  def safe_f1_score(y_true, y_score):
      y_true = np.asarray(y_true)
      if len(np.unique(y_true)) == 1:
          return 0.5  # return np.nan where the score cannot be calculated
      return f1_score(y_true, y_score, average='weighted')
      #+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  def rescale_coefs(model, coefs, bias):

          try:
                  means = model.named_steps["scaler"].mean_
                  scales = model.named_steps["scaler"].scale_

                  # Rescale the coefficients
                  rescaled_coefs = np.true_divide(coefs, scales)

                  # Adjust the intercept
                  rescaled_bias = bias - np.sum(rescaled_coefs * means)

                  return rescaled_coefs, rescaled_bias
          except:
                  return coefs, bias

#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  from scipy.stats import bootstrap

  def get_bootstrap_ci(data, statistic=np.mean, confidence_level=0.95, n_resamples=1000, random_state=None):
      result = bootstrap((data,), statistic)
      ci_lower, ci_upper = result.confidence_interval
      return np.array([ci_lower, ci_upper])
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  import pickle as pkl

  def pkl_save(obj, name, path="."):
      os.makedirs(path, exist_ok=True)
      destination = path + "/" + name + ".pkl"
      print("saving to", destination)
      pkl.dump(obj, open(destination, "wb"))


  def pkl_load(name, path="."):
      source = path + "/" + name + '.pkl'
      print('loading from', source)
      return pkl.load(open( source, "rb"))

#+end_src

#+RESULTS:

#+begin_src ipython
def overlaps_scorer(estimator, X_test, y_test, IF_SIGN=0):
    try:
        coef = estimator.named_steps["model"].coef_.flatten()
        clf = estimator #.named_steps["model"]
    except:
        coef = estimator.best_estimator_.named_steps["model"].coef_.flatten()
        clf = estimator.best_estimator_.named_steps["model"]

    norm_w = np.linalg.norm(coef) + 1e-6

    if IF_SIGN:
        dot_product = (2*y_test -1) * np.dot(X_test, coef)
        # dot_product = (2*y_test -1) * clf.named_steps["model"].decision_function(X_test)
        # dot_product = (2*y_test -1) * clf.decision_function(X_test)
    else:
        # dot_product = clf.decision_function(X_test)
        # dot_product = clf.named_steps["model"].decision_function(X_test)
        dot_product = np.dot(X_test, coef)

    return np.nanmean(dot_product) / norm_w
#+end_src

#+RESULTS:

* Plots

#+begin_src ipython
def significance_marker(p):
    if p < 0.001:
        return '***'
    elif p < 0.01:
        return '**'
    elif p < 0.05:
        return '*'
    elif p <.1:
        return '.'
    else:
        return ''
#+end_src

#+RESULTS:

#+begin_src ipython
import rpy2.robjects as robjects
from rpy2.robjects.packages import importr

# Set the .libPaths in R
custom_r_libpath = '~/R/x86_64-pc-linux-gnu-library/4.3/'
robjects.r('.libPaths("{0}")'.format(custom_r_libpath))

from pymer4.models import Lmer
#+end_src

#+RESULTS:

#+begin_src ipython
def plot_overlaps(df, day, epoch, ax, title='', y0=0.5, size=84, if_proba=0, ls='-', label=None, colors=None, cis=None, **kwargs):
    if day=='all':
        df_ = df.copy()
    else:
        df_ = df[df.day == day].copy()

    if colors is None:
        colors = ['r', 'b', 'g']

    if if_proba:
        mean_overlaps = df_.groupby('tasks')['sign_overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))

        if cis is not None:
            lower_cis = df_.groupby('tasks')['sign_overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 0))
            upper_cis = df_.groupby('tasks')['sign_overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 1))

    else:
        mean_overlaps = df_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))

        if cis is not None:
            lower_cis = df_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 0))
            upper_cis = df_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 1))

    time_points = np.linspace(0, 14, size)

    for i, task in enumerate(mean_overlaps.index):
        if label is None:
            ax.plot(time_points, mean_overlaps[task], label=f"{task}", color=colors[i], ls=ls, **kwargs)
            # ax.fill_between(time_points, lower_cis[task], upper_cis[task], color=colors[i], alpha=0.1)
        else:
            ax.plot(time_points, mean_overlaps[task], label=label, color=colors[i], ls=ls, **kwargs)

        if cis is not None:
            ax.fill_between(time_points, lower_cis[task], upper_cis[task], color=colors[i], alpha=0.1)

    ax.set_xlabel('Time (s)')
    # ax.set_ylabel('%s Overlap' % title)
    add_vlines(ax)
    ax.axhline(y0, ls='--', color='k')
    ax.legend(fontsize=10)

def bootstrap_ci_per_task(x, n_bootstrap, ci_idx):
    stacked = np.stack(x)
    return np.array([bootstrap_ci(stacked[:, i], n_bootstrap)[ci_idx] for i in range(stacked.shape[1])])
#+end_src

#+RESULTS:

#+begin_src ipython
def plot_overlaps_traj(df, df2, day, epoch, ax, title='', y0=0.5, size=84, if_proba=0, ls='-', label=None, colors=None, cis=None, **kwargs):
    if day=='all':
        df_ = df.copy()
        df2_ = df2.copy()
    else:
        df_ = df[df.day == day].copy()
        df2_ = df[df.day == day].copy()

    if colors is None:
        colors = ['r', 'b', 'g']

    if if_proba:
        mean_overlaps = df_.groupby('tasks')['sign_overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))
        mean_overlaps2 = df2_.groupby('tasks')['sign_overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))

        if cis is not None:
            lower_cis = df_.groupby('tasks')['sign_overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 0))
            upper_cis = df_.groupby('tasks')['sign_overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 1))

    else:
        mean_overlaps = df_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))
        mean_overlaps2 = df2_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))

        if cis is not None:
            lower_cis = df_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 0))
            upper_cis = df_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: bootstrap_ci_per_task(x, 1000, 1))

    time_points = np.linspace(0, 14, size)

    for i, task in enumerate(mean_overlaps.index):
        if label is None:
            ax.plot(time_points, mean_overlaps[task], label=f"{task}", color=colors[i], ls=ls, **kwargs)
            # ax.fill_between(time_points, lower_cis[task], upper_cis[task], color=colors[i], alpha=0.1)
        else:
            ax.plot(time_points, mean_overlaps[task], label=label, color=colors[i], ls=ls, **kwargs)

        if cis is not None:
            ax.fill_between(time_points, lower_cis[task], upper_cis[task], color=colors[i], alpha=0.1)

    ax.set_xlabel('Time (s)')
    # ax.set_ylabel('%s Overlap' % title)
    add_vlines(ax)
    ax.axhline(y0, ls='--', color='k')
    ax.legend(fontsize=10)

def bootstrap_ci_per_task(x, n_bootstrap, ci_idx):
    stacked = np.stack(x)
    return np.array([bootstrap_ci(stacked[:, i], n_bootstrap)[ci_idx] for i in range(stacked.shape[1])])
#+end_src

#+RESULTS:

#+begin_src ipython
def bootstrap_ci(data, n_bootstrap=1000, ci=95):
    bootstrapped_means = np.array([np.mean(np.random.choice(data, size=len(data))) for _ in range(n_bootstrap)])
    lower_bound = np.percentile(bootstrapped_means, (100-ci)/2)
    upper_bound = np.percentile(bootstrapped_means, 100 - (100-ci)/2)
    return lower_bound, upper_bound
#+end_src

#+RESULTS:

#+begin_src ipython
def plot_mat(X, ax, vmin=-1, vmax=1):
  im = ax.imshow(
    X,
    interpolation="lanczos",
    origin="lower",
    cmap="jet",
    extent=[0, 14, 0, 14],
    vmin=vmin,
    vmax=vmax,
  )

  add_vdashed(ax)
  ax.set_xlim([2, 12])
  ax.set_xticks([2, 4, 6, 8, 10, 12])
  ax.set_ylim([2, 12])
  ax.set_yticks([2, 4, 6, 8, 10, 12])

  ax.set_xlabel("Testing Time (s)")
  ax.set_ylabel("Training Time (s)")
  return im
#+end_src

#+RESULTS:

#+begin_src ipython
import matplotlib.pyplot as plt

def add_vdashed(ax=None, mouse=""):
    # Define time intervals
    t_STIM = [2, 3]
    t_DIST = [4.5, 5.5]
    t_CUE = [6.5, 7]
    t_TEST = [9, 10]

    # Add vertical dashed lines and text labels for each interval
    if ax is not None:
        # Draw vertical lines
        for t in [t_STIM, t_DIST, t_TEST]:
            ax.axvline(x=t[0], linestyle='--', color='k', lw=2)
            ax.axvline(x=t[1], linestyle='--', color='k', lw=2)

            ax.axhline(y=t[0], linestyle='--', color='k', lw=2)
            ax.axhline(y=t[1], linestyle='--', color='k', lw=2)

        # Add text labels at the middle of each interval
        ax.text((t_STIM[0] + t_STIM[1]) / 2, 12.5, 'STIM', color='black',
                horizontalalignment='center', verticalalignment='center', fontsize=16)
        ax.text((t_DIST[0] + t_DIST[1]) / 2, 12.5, 'DIST', color='black',
                horizontalalignment='center', verticalalignment='center', fontsize=16)
        # ax.text((t_CUE[0] + t_CUE[1]) / 2, 12.5, 'CUE', color='black',
        #         horizontalalignment='center', verticalalignment='center', fontsize=16)
        ax.text((t_TEST[0] + t_TEST[1]) / 2, 12.5, 'TEST', color='black',
                horizontalalignment='center', verticalalignment='center', fontsize=16)

        ax.text(12.5, (t_STIM[0] + t_STIM[1]) / 2, 'STIM', color='black',
                horizontalalignment='center', verticalalignment='center', rotation='vertical',fontsize=16)
        ax.text(12.5, (t_DIST[0] + t_DIST[1]) / 2, 'DIST', color='black',
                horizontalalignment='center', verticalalignment='center', rotation='vertical',fontsize=16)
        # ax.text(12.5, (t_CUE[0] + t_CUE[1]) / 2, 'CUE', color='black',
        #         horizontalalignment='center', verticalalignment='center', rotation='vertical', fontsize=16)
        ax.text(12.5, (t_TEST[0] + t_TEST[1]) / 2, 'TEST', color='black',
                horizontalalignment='center', verticalalignment='center', rotation='vertical', fontsize=16)

#+end_src

#+RESULTS:

#+begin_src ipython
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
def plot_overlaps_mat(df, day, vmin=-1, vmax=1, title=''):
    df_ = df[df.day == day].copy()
    colors = ['r', 'b', 'g']
    time_points = np.linspace(0, 14, 84)

    fig, ax = plt.subplots(1, 3, figsize=(15, 5))
    # fig, ax = plt.subplots(nrows=1, ncols=3, figsize=(3*width, height))

    for i, task in enumerate(df_.tasks.unique()):
        df_task = df_[df_.tasks==task]
        overlaps = df_task
        overlaps = np.array(df_task['overlaps'].tolist())

        mean_o = np.nanmean(overlaps, axis=0)

        im = plot_mat(mean_o.reshape(84, 84), ax[i], vmin, vmax)

    cax = inset_axes(ax[-1], width="5%", height="100%", loc='center right',
                     bbox_to_anchor=(0.12, 0, 1, 1), bbox_transform=ax[-1].transAxes, borderpad=0)

    # Add colorbar to the new axis
    cbar = fig.colorbar(im, cax=cax)
    cbar.set_label("%s Overlaps" % title)

    plt.subplots_adjust(right=0.85)  # Adjust figure to allocate space

#+end_src

#+RESULTS:

* Parameters

#+begin_src ipython
  DEVICE = 'cuda:0'
  old_mice = ['ChRM04','JawsM15', 'JawsM18', 'ACCM03', 'ACCM04']
  Jaws_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18']

  mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18', 'ChRM04', 'ChRM23', 'ACCM03', 'ACCM04']
  mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18', 'ChRM04', 'ChRM23']
  # mice = Jaws_mice

  tasks = ['DPA', 'DualGo', 'DualNoGo']
  # mice = ['JawsM15']

  kwargs = {
      'mice': mice,
      'mouse': mice[0], 'laser': 0,
      'trials': '', 'reload': 0, 'data_type': 'dF',
      'prescreen': None, 'pval': 0.05,
      'preprocess': False, 'scaler_BL': 'robust',
      'avg_noise':True, 'unit_var_BL': True,
      'random_state': None, 'T_WINDOW': 0.5,
      'l1_ratio': 0.95,
      'n_comp': None, 'scaler': None,
      'bootstrap': 1, 'n_boots': 128,
      'n_splits': 5, 'n_repeats': 1,
      'class_weight': 0,
      'multilabel': 0,
      'mne_estimator':'generalizing', # sliding or generalizing
      'n_jobs': 128,
  }

  # kwargs['days'] = ['first', 'middle', 'last']
  kwargs['days'] = ['first', 'last']
  # kwargs['days'] = 'all'
  options = set_options(**kwargs)

  safe_roc_auc = make_scorer(safe_roc_auc_score, needs_proba=True)
  safe_f1 = make_scorer(safe_f1_score, needs_proba=True)

  options['hp_scoring'] = lambda estimator, X_test, y_test: np.abs(overlaps_scorer(estimator, X_test, y_test, IF_SIGN=1))
  # options['hp_scoring'] = 'accuracy'
  options['scoring'] = overlaps_scorer

  # dum = 'overlaps_loocv'
  # dum = 'overlaps_loocv_laser_on'
  dum = 'overlaps_loocv_laser_all'
  options['cv_B'] = True
  # dum = 'overlaps_all_loocv'
#+end_src

#+RESULTS:

* Decoding vs days
** utils

#+begin_src ipython
def decode_axis(model, **options):
    new_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'ChRM23']
    options['NEW_DATA'] = 0

    dfs = []
    for mouse in options['mice']:
        df_mouse = []
        options['mouse'] = mouse
        options = set_options(**options)
        days = options['days']

        if mouse in new_mice:
            options['reload'] = 0
            options['NEW_DATA'] = 1
        else:
            options['reload'] = 0
            options['NEW_DATA'] = 0

        for task in ['all']:
            options['task'] = task

            for day in days:
                options['day'] = day

                try:
                # if 0==0:
                    overlaps = get_classification(model, RETURN='df_scores', **options)
                    options['reload'] = 0
                    df_mouse.append(overlaps)
                except:
                    pass

        df_mouse = pd.concat(df_mouse)
        df_mouse['mouse'] = mouse
        dfs.append(df_mouse)

    return pd.concat(dfs)
    #+end_src

#+RESULTS:

#+begin_src ipython
def save_overlaps(df, marg, dum, **options):
    if len(options['days'])>3:
        name = 'df_%s_%s_days' % (marg, dum)
    elif len(options['days'])==2:
        name = 'df_%s_%s_early_late' % (marg, dum)
    else:
        name = 'df_%s_%s' % (marg, dum)

    if len(mice)==1:
        pkl_save(df, '%s' % name, path="/storage/leon/dual_task/data/%s/overlaps" % options['mouse'])
    elif len(mice)==2:
        pkl_save(df, '%s' % name, path="/storage/leon/dual_task/data/mice/overlaps_ACC")
    else:
        pkl_save(df, '%s' % name, path="/storage/leon/dual_task/data/mice/overlaps")
#+end_src

#+RESULTS:

** run

#+begin_src ipython
import sys
sys.path.insert(0, '/home/leon/Dclassify')
from src.classificationCV import ClassificationCV
#+end_src

#+RESULTS:

#+begin_src ipython
from sklearn.linear_model import LogisticRegression
net = LogisticRegression(penalty='l1', solver='liblinear', class_weight='balanced', n_jobs=None)
# net = LogisticRegression(penalty='elasticnet', solver='saga', n_jobs=None, l1_ratio=0.95,  tol=0.001, class_weight='balanced')

params = {'model__C': np.logspace(-3, 3, 10)} # , 'net__l1_ratio': np.linspace(0, 1, 10)}

options['hp_scoring'] = lambda estimator, X_test, y_test: np.abs(overlaps_scorer(estimator, X_test, y_test, IF_SIGN=1))
options['scoring'] = overlaps_scorer

options['n_jobs'] = -1
options['reload'] = 0

options['T_WINDOW'] = 0.5

model = ClassificationCV(net, params, **options)
options['cv'] = LeaveOneOut()
options['verbose'] = 1
#+end_src

#+RESULTS:
: PCA False None

#+begin_src ipython
options['features'] = 'sample'
options['epochs'] = ['LD']
df_sample = decode_axis(model, **options)

df_sample['performance'] = df_sample['response'].apply(lambda x: 0 if 'incorrect' in x else 1)
df_sample['pair'] = df_sample['response'].apply(lambda x: 0 if (('rej' in x) or ('fa' in x)) else 1)
save_overlaps(df_sample, 'sample', dum, **options)
 #+end_src

 #+RESULTS:
 #+begin_example
 Loading files from /storage/leon/dual_task/data/JawsM01
 X_days (768, 184, 84) y_days (768, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 1
 X_B (288, 184, 84) nans 0.0 y_B (288,) [0. 1.] ['DPA' 'DualNoGo' 'DualGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 0
 y_labels (288, 14) ['DualNoGo' 'DualGo' 'DPA']
 X (288, 184, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) 0.0918187933004064
 df_A (288, 15) scores (288, 7056) labels (288, 14)
 scores_B (288, 84, 84)
 df_B (288, 15) scores (288, 7056) labels (288, 14)
 df (576, 15)
 Loading files from /storage/leon/dual_task/data/JawsM01X_days (768, 184, 84) y_days (768, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 1
 X_B (96, 184, 84) nans 0.0 y_B (96,) [0. 1.] ['DualNoGo' 'DPA' 'DualGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 0
 y_labels (96, 14) ['DPA' 'DualGo' 'DualNoGo']
 X (96, 184, 84) nans 0.0 y (96,) [0. 1.]
 scores (2, 96, 84, 84) 0.04008270988349035
 df_A (96, 15) scores (96, 7056) labels (96, 14)
 scores_B (96, 84, 84)
 df_B (96, 15) scores (96, 7056) labels (96, 14)
 df (192, 15)
 Loading files from /storage/leon/dual_task/data/JawsM06
 X_days (1152, 201, 84) y_days (1152, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 1
 X_B (288, 201, 84) nans 0.0 y_B (288,) [0. 1.] ['DPA' 'DualGo' 'DualNoGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 0
 y_labels (288, 14) ['DualNoGo' 'DualGo' 'DPA']
 X (288, 201, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.018780271458937337
 df_A (288, 15) scores (288, 7056) labels (288, 14)
 scores_B (288, 84, 84)
 df_B (288, 15) scores (288, 7056) labels (288, 14)
 df (576, 15)
 Loading files from /storage/leon/dual_task/data/JawsM06
 X_days (1152, 201, 84) y_days (1152, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 1
 X_B (288, 201, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 0
 y_labels (288, 14) ['DualGo' 'DualNoGo' 'DPA']
 X (288, 201, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.035424455726088405
 df_A (288, 15) scores (288, 7056) labels (288, 14)
 scores_B (288, 84, 84)
 df_B (288, 15) scores (288, 7056) labels (288, 14)
 df (576, 15)
 Loading files from /storage/leon/dual_task/data/JawsM12
 X_days (960, 423, 84) y_days (960, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 1
 X_B (288, 423, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DPA' 'DualGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 0
 y_labels (288, 14) ['DPA' 'DualGo' 'DualNoGo']
 X (288, 423, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.10442241351009879
 df_A (288, 15) scores (288, 7056) labels (288, 14)
 scores_B (288, 84, 84)
 df_B (288, 15) scores (288, 7056) labels (288, 14)
 df (576, 15)
 Loading files from /storage/leon/dual_task/data/JawsM12
 X_days (960, 423, 84) y_days (960, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 1
 X_B (192, 423, 84) nans 0.0 y_B (192,) [0. 1.] ['DualNoGo' 'DPA' 'DualGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 0
 y_labels (192, 14) ['DPA' 'DualGo' 'DualNoGo']
 X (192, 423, 84) nans 0.0 y (192,) [0. 1.]
 scores (2, 192, 84, 84) -0.07388688343578313
 df_A (192, 15) scores (192, 7056) labels (192, 14)
 scores_B (192, 84, 84)
 df_B (192, 15) scores (192, 7056) labels (192, 14)
 df (384, 15)
 Loading files from /storage/leon/dual_task/data/JawsM15
 X_days (1152, 693, 84) y_days (1152, 15)
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 1
 X_B (288, 693, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DPA' 'DualGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 0
 y_labels (288, 16) ['DualGo' 'DPA' 'DualNoGo']
 X (288, 693, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.12971185216550546
 df_A (288, 17) scores (288, 7056) labels (288, 16)
 scores_B (288, 84, 84)
 df_B (288, 17) scores (288, 7056) labels (288, 16)
 df (576, 17)
 Loading files from /storage/leon/dual_task/data/JawsM15
 X_days (1152, 693, 84) y_days (1152, 15)
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 1
 X_B (288, 693, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 0
 y_labels (288, 16) ['DualGo' 'DualNoGo' 'DPA']
 X (288, 693, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.09505257134152163
 df_A (288, 17) scores (288, 7056) labels (288, 16)
 scores_B (288, 84, 84)
 df_B (288, 17) scores (288, 7056) labels (288, 16)
 df (576, 17)
 Loading files from /storage/leon/dual_task/data/JawsM18
 X_days (1152, 444, 84) y_days (1152, 15)
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 1
 X_B (288, 444, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 0
 y_labels (288, 16) ['DualNoGo' 'DualGo' 'DPA']
 X (288, 444, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.07366072410269682
 df_A (288, 17) scores (288, 7056) labels (288, 16)
 scores_B (288, 84, 84)
 df_B (288, 17) scores (288, 7056) labels (288, 16)
 df (576, 17)
 Loading files from /storage/leon/dual_task/data/JawsM18
 X_days (1152, 444, 84) y_days (1152, 15)
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 1
 X_B (288, 444, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DPA' 'DualGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 0
 y_labels (288, 16) ['DPA' 'DualNoGo' 'DualGo']
 X (288, 444, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.05307031643203323
 df_A (288, 17) scores (288, 7056) labels (288, 16)
 scores_B (288, 84, 84)
 df_B (288, 17) scores (288, 7056) labels (288, 16)
 df (576, 17)
 Loading files from /storage/leon/dual_task/data/ChRM04
 X_days (1152, 668, 84) y_days (1152, 15)
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 1
 X_B (288, 668, 84) nans 0.0 y_B (288,) [0. 1.] ['DualGo' 'DPA' 'DualNoGo']
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 0
 y_labels (288, 16) ['DualNoGo' 'DPA' 'DualGo']
 X (288, 668, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.07392346736540618
 df_A (288, 17) scores (288, 7056) labels (288, 16)
 scores_B (288, 84, 84)
 df_B (288, 17) scores (288, 7056) labels (288, 16)
 df (576, 17)
 Loading files from /storage/leon/dual_task/data/ChRM04
 X_days (1152, 668, 84) y_days (1152, 15)
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 1
 X_B (288, 668, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 0
 y_labels (288, 16) ['DualNoGo' 'DualGo' 'DPA']
 X (288, 668, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.16665932793259494
 df_A (288, 17) scores (288, 7056) labels (288, 16)
 scores_B (288, 84, 84)
 df_B (288, 17) scores (288, 7056) labels (288, 16)
 df (576, 17)
 Loading files from /storage/leon/dual_task/data/ChRM23
 X_days (960, 232, 84) y_days (960, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 1
 X_B (288, 232, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
 DATA: FEATURES sample TASK all TRIALS  DAYS first LASER 0
 y_labels (288, 14) ['DualGo' 'DPA' 'DualNoGo']
 X (288, 232, 84) nans 0.0 y (288,) [0. 1.]
 scores (2, 288, 84, 84) -0.1494395209476997
 df_A (288, 15) scores (288, 7056) labels (288, 14)
 scores_B (288, 84, 84)
 df_B (288, 15) scores (288, 7056) labels (288, 14)
 df (576, 15)
 Loading files from /storage/leon/dual_task/data/ChRM23
 X_days (960, 232, 84) y_days (960, 13)
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 1
 X_B (192, 232, 84) nans 0.0 y_B (192,) [0. 1.] ['DualGo' 'DualNoGo' 'DPA']
 DATA: FEATURES sample TASK all TRIALS  DAYS last LASER 0
 y_labels (192, 14) ['DualNoGo' 'DualGo' 'DPA']
 X (192, 232, 84) nans 0.0 y (192,) [0. 1.]
 scores (2, 192, 84, 84) -0.10518125604619517
 df_A (192, 15) scores (192, 7056) labels (192, 14)
 scores_B (192, 84, 84)
 df_B (192, 15) scores (192, 7056) labels (192, 14)
 df (384, 15)
 saving to /storage/leon/dual_task/data/mice/overlaps/df_sample_overlaps_loocv_laser_all_early_late.pkl
 #+end_example

#+begin_src ipython
options['features'] = 'choice'
options['epochs'] = ['CHOICE']
df_choice = decode_axis(model, **options)

df_choice['performance'] = df_choice['response'].apply(lambda x: 0 if 'incorrect' in x else 1)
df_choice['pair'] = df_choice['response'].apply(lambda x: 0 if (('rej' in x) or ('fa' in x)) else 1)
save_overlaps(df_choice, 'choice', dum, **options)
#+end_src

#+RESULTS:
#+begin_example
Loading files from /storage/leon/dual_task/data/JawsM01
X_days (768, 184, 84) y_days (768, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 1
X_B (288, 184, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DPA' 'DualGo']
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 0
y_labels (288, 14) ['DualGo' 'DPA' 'DualNoGo']
X (288, 184, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) -0.05270526649422442
df_A (288, 15) scores (288, 7056) labels (288, 14)
scores_B (288, 84, 84)
df_B (288, 15) scores (288, 7056) labels (288, 14)
df (576, 15)
Loading files from /storage/leon/dual_task/data/JawsM01
X_days (768, 184, 84) y_days (768, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 1
X_B (96, 184, 84) nans 0.0 y_B (96,) [0. 1.] ['DPA' 'DualNoGo' 'DualGo']
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 0
y_labels (96, 14) ['DPA' 'DualGo' 'DualNoGo']
X (96, 184, 84) nans 0.0 y (96,) [0. 1.]
scores (2, 96, 84, 84) -0.058023385007039324
df_A (96, 15) scores (96, 7056) labels (96, 14)
scores_B (96, 84, 84)
df_B (96, 15) scores (96, 7056) labels (96, 14)
df (192, 15)
Loading files from /storage/leon/dual_task/data/JawsM06
X_days (1152, 201, 84) y_days (1152, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 1
X_B (288, 201, 84) nans 0.0 y_B (288,) [0. 1.] ['DualGo' 'DPA' 'DualNoGo']
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 0
y_labels (288, 14) ['DPA' 'DualNoGo' 'DualGo']
X (288, 201, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.037509416602632184
df_A (288, 15) scores (288, 7056) labels (288, 14)
scores_B (288, 84, 84)
df_B (288, 15) scores (288, 7056) labels (288, 14)
df (576, 15)
Loading files from /storage/leon/dual_task/data/JawsM06
X_days (1152, 201, 84) y_days (1152, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 1
X_B (288, 201, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 0
y_labels (288, 14) ['DualGo' 'DualNoGo' 'DPA']
X (288, 201, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.03068642534233641
df_A (288, 15) scores (288, 7056) labels (288, 14)
scores_B (288, 84, 84)
df_B (288, 15) scores (288, 7056) labels (288, 14)
df (576, 15)
Loading files from /storage/leon/dual_task/data/JawsM12
X_days (960, 423, 84) y_days (960, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 1
X_B (288, 423, 84) nans 0.0 y_B (288,) [0. 1.] ['DPA' 'DualGo' 'DualNoGo']
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 0
y_labels (288, 14) ['DPA' 'DualGo' 'DualNoGo']
X (288, 423, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.02680700273803714
df_A (288, 15) scores (288, 7056) labels (288, 14)
scores_B (288, 84, 84)
df_B (288, 15) scores (288, 7056) labels (288, 14)
df (576, 15)
Loading files from /storage/leon/dual_task/data/JawsM12
X_days (960, 423, 84) y_days (960, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 1
X_B (192, 423, 84) nans 0.0 y_B (192,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 0
y_labels (192, 14) ['DualNoGo' 'DualGo' 'DPA']
X (192, 423, 84) nans 0.0 y (192,) [0. 1.]
scores (2, 192, 84, 84) 0.022023375708394948
df_A (192, 15) scores (192, 7056) labels (192, 14)
scores_B (192, 84, 84)
df_B (192, 15) scores (192, 7056) labels (192, 14)
df (384, 15)
Loading files from /storage/leon/dual_task/data/JawsM15
X_days (1152, 693, 84) y_days (1152, 15)
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 1
X_B (288, 693, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DPA' 'DualGo']
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 0
y_labels (288, 16) ['DualGo' 'DPA' 'DualNoGo']
X (288, 693, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.11358052017776443
df_A (288, 17) scores (288, 7056) labels (288, 16)
scores_B (288, 84, 84)
df_B (288, 17) scores (288, 7056) labels (288, 16)
df (576, 17)
Loading files from /storage/leon/dual_task/data/JawsM15
X_days (1152, 693, 84) y_days (1152, 15)
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 1
X_B (288, 693, 84) nans 0.0 y_B (288,) [0. 1.] ['DualGo' 'DPA' 'DualNoGo']
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 0
y_labels (288, 16) ['DualGo' 'DualNoGo' 'DPA']
X (288, 693, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) -0.023478235088931522
df_A (288, 17) scores (288, 7056) labels (288, 16)
scores_B (288, 84, 84)
df_B (288, 17) scores (288, 7056) labels (288, 16)
df (576, 17)
Loading files from /storage/leon/dual_task/data/JawsM18
X_days (1152, 444, 84) y_days (1152, 15)
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 1
X_B (288, 444, 84) nans 0.0 y_B (288,) [0. 1.] ['DPA' 'DualNoGo' 'DualGo']
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 0
y_labels (288, 16) ['DPA' 'DualNoGo' 'DualGo']
X (288, 444, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.14230032740958173
df_A (288, 17) scores (288, 7056) labels (288, 16)
scores_B (288, 84, 84)
df_B (288, 17) scores (288, 7056) labels (288, 16)
df (576, 17)
Loading files from /storage/leon/dual_task/data/JawsM18
X_days (1152, 444, 84) y_days (1152, 15)
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 1
X_B (288, 444, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 0
y_labels (288, 16) ['DPA' 'DualGo' 'DualNoGo']
X (288, 444, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.034573805905935576
df_A (288, 17) scores (288, 7056) labels (288, 16)
scores_B (288, 84, 84)
df_B (288, 17) scores (288, 7056) labels (288, 16)
df (576, 17)
Loading files from /storage/leon/dual_task/data/ChRM04
X_days (1152, 668, 84) y_days (1152, 15)
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 1
X_B (288, 668, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 0
y_labels (288, 16) ['DualNoGo' 'DualGo' 'DPA']
X (288, 668, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.0910253099655545
df_A (288, 17) scores (288, 7056) labels (288, 16)
scores_B (288, 84, 84)
df_B (288, 17) scores (288, 7056) labels (288, 16)
df (576, 17)
Loading files from /storage/leon/dual_task/data/ChRM04
X_days (1152, 668, 84) y_days (1152, 15)
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 1
X_B (288, 668, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 0
y_labels (288, 16) ['DualGo' 'DPA' 'DualNoGo']
X (288, 668, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.028287170025465314
df_A (288, 17) scores (288, 7056) labels (288, 16)
scores_B (288, 84, 84)
df_B (288, 17) scores (288, 7056) labels (288, 16)
df (576, 17)
Loading files from /storage/leon/dual_task/data/ChRM23
X_days (960, 232, 84) y_days (960, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 1
X_B (288, 232, 84) nans 0.0 y_B (288,) [0. 1.] ['DualNoGo' 'DualGo' 'DPA']
DATA: FEATURES choice TASK all TRIALS  DAYS first LASER 0
y_labels (288, 14) ['DualGo' 'DPA' 'DualNoGo']
X (288, 232, 84) nans 0.0 y (288,) [0. 1.]
scores (2, 288, 84, 84) 0.10504244987632766
df_A (288, 15) scores (288, 7056) labels (288, 14)
scores_B (288, 84, 84)
df_B (288, 15) scores (288, 7056) labels (288, 14)
df (576, 15)
Loading files from /storage/leon/dual_task/data/ChRM23
X_days (960, 232, 84) y_days (960, 13)
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 1
X_B (192, 232, 84) nans 0.0 y_B (192,) [0. 1.] ['DPA' 'DualGo' 'DualNoGo']
DATA: FEATURES choice TASK all TRIALS  DAYS last LASER 0
y_labels (192, 14) ['DualNoGo' 'DualGo' 'DPA']
X (192, 232, 84) nans 0.0 y (192,) [0. 1.]
scores (2, 192, 84, 84) 0.0828217201852656
df_A (192, 15) scores (192, 7056) labels (192, 14)
scores_B (192, 84, 84)
df_B (192, 15) scores (192, 7056) labels (192, 14)
df (384, 15)
saving to /storage/leon/dual_task/data/mice/overlaps/df_choice_overlaps_loocv_laser_all_early_late.pkl
#+end_example

#+begin_src ipython

#+end_src

#+RESULTS:

* Data
** utils

#+begin_src ipython
def load_data(marg, dum, **options):
    if len(options['days'])>3:
        name = 'df_%s_%s_days' % (marg, dum)
    elif len(options['days'])==2:
        name = 'df_%s_%s_early_late' % (marg, dum)
    else:
        name = 'df_%s_%s' % (marg, dum)

    if len(options['mice'])==1:
        df = pkl_load('%s' % name, path="/storage/leon/dual_task/data/%s/overlaps" % options['mouse'])
    elif len(options['mice'])==2:
        df = pkl_load('%s' % name, path="/storage/leon/dual_task/data/mice/overlaps_ACC")
    else:
        df = pkl_load('%s' % name, path="/storage/leon/dual_task/data/mice/overlaps")#.reset_index()

    return df
#+end_src

#+RESULTS:

#+begin_src ipython
def get_avg_overlaps(df, epoch_list, **options):

        df['overlaps_diag'] = df['overlaps'].apply(lambda x: np.diag(np.array(x).reshape(84, 84)))

        for epoch2 in epoch_list:
                options['epochs'] = [epoch2]
                df['overlaps_diag_%s' % epoch2] = df['overlaps_diag'].apply(lambda x: avg_epochs(np.array(x), **options))

        for epoch in epoch_list:
                options['epochs'] = [epoch]
                df['overlaps_%s' % epoch] = df['overlaps'].apply(lambda x: avg_epochs(np.array(x).reshape(84, 84).T, **options))

                for epoch2 in epoch_list:
                        options['epochs'] = [epoch2]
                        df['overlaps_%s_%s' % (epoch, epoch2)] = df['overlaps_%s' % epoch].apply(lambda x: avg_epochs(np.array(x), **options))


        return df
#+end_src

#+RESULTS:

** run

#+begin_src ipython
options['T_WINDOW'] = 0.5
options = set_options(**options)
#+end_src

#+RESULTS:

#+begin_src ipython
df_sample = load_data('sample', dum, **options)
df_sample = get_avg_overlaps(df_sample, ['ED', 'LD', 'TEST'], **options)
#+end_src

#+RESULTS:
: loading from /storage/leon/dual_task/data/mice/overlaps/df_sample_overlaps_loocv_laser_all_early_late.pkl

#+begin_src ipython
# df_choice = load_data('choice', 'overlaps_loocv', **options)
df_choice = get_avg_overlaps(df_choice,  ['LD', 'TEST', 'CHOICE'], **options)
#+end_src

#+RESULTS:

#+begin_src ipython
print(df_sample.laser.unique())
#+end_src

#+RESULTS:
: [1. 0.]

#+begin_src ipython
df = df_choice.copy()
# df = df[df.laser==1]
Jaws_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18']
# Jaws_mice = ['ChRM04', 'ChRM23']
df = df[df.mouse.isin(Jaws_mice)]

overlaps = 'overlaps_TEST_LD'

fig, ax = plt.subplots(nrows=1, ncols=3, figsize=(3 * width, height), sharey=1)

df_ = df[df.tasks=='DPA']
sns.lineplot(data=df_, x='day', y=overlaps, hue='mouse', marker='o', legend=0, palette=[ 'b', 'r', 'g'], ax=ax[0], alpha=.2, ci=None)

df_ = df[df.tasks=='DualGo']
sns.lineplot(data=df_, x='day', y=overlaps, hue='mouse', marker='o', legend=0, palette=[ 'b', 'r', 'g'], ax=ax[1], alpha=.2, ci=None)

df_ = df[df.tasks=='DualNoGo']
sns.lineplot(data=df_, x='day', y=overlaps, hue='mouse', marker='o', legend=0, palette=[ 'b', 'r', 'g'], ax=ax[2], alpha=.2, ci=None)

for i in range(3):
    ax[i].axhline(0, ls='--', color='k')

plt.show()
#+end_src

#+RESULTS:
[[./figures/sample_overlaps/figure_31.png]]

#+begin_src ipython
import rpy2.robjects as robjects
from rpy2.robjects.packages import importr

# Set the .libPaths in R
custom_r_libpath = '~/R/x86_64-pc-linux-gnu-library/4.3/'
robjects.r('.libPaths("{0}")'.format(custom_r_libpath))

from pymer4.models import Lmer
#+end_src

#+RESULTS:

#+begin_src ipython
df.mouse.unique()
#+end_src

#+RESULTS:
: array(['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18', 'ChRM04',
:        'ChRM23'], dtype=object)

#+begin_src ipython
df_choice['perf'] = df_choice['performance'] * df_choice['odr_perf']
print(df.keys())
#+end_src

#+RESULTS:
: Index(['index', 'sample_odor', 'dist_odor', 'test_odor', 'tasks', 'response',
:        'laser', 'day', 'choice', 'pair', 'odr_perf', 'odr_choice',
:        'odr_response', 'idx', 'overlaps', 'mouse', 'performance', 'odor_pair',
:        'overlaps_diag', 'overlaps_diag_LD', 'overlaps_diag_TEST',
:        'overlaps_diag_CHOICE', 'overlaps_LD', 'overlaps_LD_LD',
:        'overlaps_LD_TEST', 'overlaps_LD_CHOICE', 'overlaps_TEST',
:        'overlaps_TEST_LD', 'overlaps_TEST_TEST', 'overlaps_TEST_CHOICE',
:        'overlaps_CHOICE', 'overlaps_CHOICE_LD', 'overlaps_CHOICE_TEST',
:        'overlaps_CHOICE_CHOICE'],
:       dtype='object')

#+begin_src ipython
import statsmodels.api as sm
import statsmodels.formula.api as smf

df = df_choice.copy()
# df=df[df.choice==0]
Jaws_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18']
# Jaws_mice = ['ChRM04', 'ChRM23']

df = df[df.mouse.isin(Jaws_mice)]
# df = df[df.day=='last']
formula = 'overlaps_CHOICE_LD ~ laser*day'

# We create a model like this
model = smf.glm(formula=formula, data=df, family=sm.families.Gaussian())
results = model.fit()

print(results.summary())
#+end_src

#+RESULTS:
#+begin_example
                 Generalized Linear Model Regression Results
==============================================================================
Dep. Variable:     overlaps_CHOICE_LD   No. Observations:                 5184
Model:                            GLM   Df Residuals:                     5180
Model Family:                Gaussian   Df Model:                            3
Link Function:               Identity   Scale:                         0.26280
Method:                          IRLS   Log-Likelihood:                -3890.0
Date:                Mon, 26 May 2025   Deviance:                       1361.3
Time:                        18:00:27   Pearson chi2:                 1.36e+03
No. Iterations:                     3   Pseudo R-squ. (CS):            0.05181
Covariance Type:            nonrobust
=====================================================================================
                        coef    std err          z      P>|z|      [0.025      0.975]
-------------------------------------------------------------------------------------
Intercept             0.0628      0.014      4.648      0.000       0.036       0.089
day[T.last]          -0.0601      0.020     -2.968      0.003      -0.100      -0.020
laser                -0.0635      0.019     -3.325      0.001      -0.101      -0.026
laser:day[T.last]    -0.1935      0.029     -6.753      0.000      -0.250      -0.137
=====================================================================================
#+end_example

#+begin_src ipython
df = df_choice.copy()
Jaws_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18']
df = df[df.mouse.isin(Jaws_mice)]
df = df[df.day=='last']
formula = 'performance ~ laser + (1 | mouse)'
model = Lmer(formula=formula, data=df, family='binomial')

results = model.fit()
print(results)
#+end_src

#+RESULTS:
#+begin_example
Linear mixed model fit by maximum likelihood  ['lmerMod']
Formula: performance~laser+(1|mouse)

Family: binomial	 Inference: parametric

Number of observations: 2304	 Groups: {'mouse': 5.0}

Log-likelihood: -814.419 	 AIC: 1634.839

Random effects:

              Name    Var    Std
mouse  (Intercept)  1.044  1.022

No random effect correlations specified

Fixed effects:

             Estimate  2.5_ci  97.5_ci     SE      OR  OR_2.5_ci  OR_97.5_ci  \
(Intercept)     2.330   1.405    3.255  0.472  10.278      4.076      25.919
laser          -0.115  -0.367    0.136  0.128   0.891      0.693       1.145

              Prob  Prob_2.5_ci  Prob_97.5_ci  Z-stat  P-val  Sig
(Intercept)  0.911        0.803         0.963   4.937  0.000  ***
laser        0.471        0.409         0.534  -0.901  0.368
#+end_example

#+begin_src ipython
df = df_choice.copy()
# df = df[df.laser==0]

formula = 'performance ~ overlaps_CHOICE_TEST * day+ (1 | mouse)'
model = Lmer(formula=formula, data=df, family='binomial')

results = model.fit()
print(results)
#+end_src

#+RESULTS:
#+begin_example
Linear mixed model fit by maximum likelihood  ['lmerMod']
Formula: performance~overlaps_CHOICE_TEST*day+(1|mouse)

Family: binomial	 Inference: parametric

Number of observations: 3648	 Groups: {'mouse': 7.0}

Log-likelihood: -1759.634 	 AIC: 3529.268

Random effects:

              Name    Var    Std
mouse  (Intercept)  0.229  0.479

No random effect correlations specified

Fixed effects:

                              Estimate  2.5_ci  97.5_ci     SE     OR  \
(Intercept)                      1.015   0.646    1.384  0.188  2.759
overlaps_CHOICE_TEST            -0.222  -0.401   -0.044  0.091  0.801
daylast                          1.043   0.855    1.230  0.096  2.838
overlaps_CHOICE_TEST:daylast     0.682   0.396    0.969  0.146  1.978

                              OR_2.5_ci  OR_97.5_ci   Prob  Prob_2.5_ci  \
(Intercept)                       1.908       3.991  0.734        0.656
overlaps_CHOICE_TEST              0.670       0.957  0.445        0.401
daylast                           2.352       3.423  0.739        0.702
overlaps_CHOICE_TEST:daylast      1.486       2.634  0.664        0.598

                              Prob_97.5_ci  Z-stat  P-val  Sig
(Intercept)                          0.800   5.392  0.000  ***
overlaps_CHOICE_TEST                 0.489  -2.440  0.015    *
daylast                              0.774  10.903  0.000  ***
overlaps_CHOICE_TEST:daylast         0.725   4.670  0.000  ***
#+end_example


 #+begin_src ipython
n_ = len(options['days'])+1
fig, ax = plt.subplots(nrows=3, ncols=n_, figsize=(n_*width, 3*height))

Jaws_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18']
# Jaws_mice = ['ChRM04', 'ChRM23']# print(df.mouse.unique(), df.shape)

epoch= 'LD'
epoch1= 'CHOICE'

df = df_sample.copy()
df1 = df_choice.copy()

df = df[df.mouse.isin(Jaws_mice)]
df1 = df1[df1.mouse.isin(Jaws_mice)]

df = df[df.laser==1]
df1 = df1[df1.laser==1]

# df = df[df.mouse=='JawsM15']
# df1 = df1[df1.mouse=='JawsM15']

ls = ['-', '--', '--', '-']
colors = ['r', 'b', 'g']
labels = ['AC', 'BC', 'AD', 'BD']
tasks = ['DPA', 'DualGo', 'DualNoGo']

for k in range(3):
    df_ = df[df.tasks==tasks[k]]
    df1_ = df1[df1.tasks==tasks[k]]

    for j in range(2):
        for i in range(2):
            df__ = df_[(df_.sample_odor==i) & (df_.test_odor==j)]
            df1__ = df1_[(df1_.sample_odor==i) & (df1_.test_odor==j)]

            plot_overlaps(df__, 'first', epoch, ax[k][0], y0=0., if_proba=0, label=labels[2*i+j],
                          cis=None, ls=ls[2*i+j], colors=[colors[k]], alpha=(i+1)/2)
            plot_overlaps(df1__, 'first', epoch1, ax[k][1], y0=0., if_proba=0, label=labels[2*i+j],
                          cis=None, ls=ls[2*i+j], colors=[colors[k]], alpha=(i+1)/2)

            overlaps = df__[df__.day=='first'].groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))
            overlaps1 = df1__[df1__.day=='first'].groupby('tasks')['overlaps_%s' % epoch1].apply(lambda x: np.nanmean(np.stack(x), axis=0))

            ax[k][2].plot(overlaps[0][:65], overlaps1[0][:65], label=labels[2*i+j],
                          ls=ls[2*i+j], color=colors[k], alpha=(i+1)/2)

            # ax[k][2].set_xlim([-0.8, 0.8])
            # ax[k][2].set_ylim([-0.5, 0.5])
            # ax[k][2].set_aspect('equal')

        ax[k][0].set_xlabel('Time (s)')
        ax[k][0].set_ylabel('Sample Overlap')

        ax[k][1].set_xlabel('Time (s)')
        ax[k][1].set_ylabel('Choice Overlap')

        ax[k][2].set_xlabel('Sample Overlap')
        ax[k][2].set_ylabel('Choice Overlap')

ax[0][-1].legend(fontsize=10)

plt.savefig('figures/icrm/choice_overlaps_%s.svg' % epoch, dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[./figures/sample_overlaps/figure_34.png]]

 #+begin_src ipython
n_ = len(options['days'])+1
fig, ax = plt.subplots(nrows=3, ncols=n_, figsize=(n_*width, 3*height))

Jaws_mice = ['JawsM01', 'JawsM06', 'JawsM12', 'JawsM15', 'JawsM18']
# Jaws_mice = ['ChRM04', 'ChRM23']# print(df.mouse.unique(), df.shape)

epoch= 'LD'
epoch1= 'CHOICE'

df = df_sample.copy()
df1 = df_choice.copy()

df = df[df.mouse.isin(Jaws_mice)]
df1 = df1[df1.mouse.isin(Jaws_mice)]

df = df[df.laser==1]
df1 = df1[df1.laser==1]

# df = df[df.mouse=='JawsM15']
# df1 = df1[df1.mouse=='JawsM15']

ls = ['-', '--', '--', '-']
colors = ['r', 'b', 'g']
labels = ['AC', 'BC', 'AD', 'BD']
tasks = ['DPA', 'DualGo', 'DualNoGo']

for k in range(3):
    df_ = df[df.tasks==tasks[k]]
    df1_ = df1[df1.tasks==tasks[k]]

    for j in range(2):
        for i in range(2):
            df__ = df_[(df_.sample_odor==i) & (df_.test_odor==j)]
            df1__ = df1_[(df1_.sample_odor==i) & (df1_.test_odor==j)]

            plot_overlaps(df__, 'last', epoch, ax[k][0], y0=0., if_proba=0, label=labels[2*i+j],
                          cis=None, ls=ls[2*i+j], colors=[colors[k]], alpha=(i+1)/2)
            plot_overlaps(df1__, 'last', epoch1, ax[k][1], y0=0., if_proba=0, label=labels[2*i+j],
                          cis=None, ls=ls[2*i+j], colors=[colors[k]], alpha=(i+1)/2)

            overlaps = df__[df__.day=='last'].groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))
            overlaps1 = df1__[df1__.day=='last'].groupby('tasks')['overlaps_%s' % epoch1].apply(lambda x: np.nanmean(np.stack(x), axis=0))

            ax[k][2].plot(overlaps[0][:65], overlaps1[0][:65], label=labels[2*i+j],
                          ls=ls[2*i+j], color=colors[k], alpha=(i+1)/2)

            # ax[k][2].set_xlim([-0.8, 0.8])
            # ax[k][2].set_ylim([-0.5, 0.5])
            # ax[k][2].set_aspect('equal')

        ax[k][0].set_xlabel('Time (s)')
        ax[k][0].set_ylabel('Sample Overlap')

        ax[k][1].set_xlabel('Time (s)')
        ax[k][1].set_ylabel('Choice Overlap')

        ax[k][2].set_xlabel('Sample Overlap')
        ax[k][2].set_ylabel('Choice Overlap')

ax[0][-1].legend(fontsize=10)

plt.savefig('figures/icrm/choice_overlaps_%s.svg' % epoch, dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[./figures/sample_overlaps/figure_35.png]]

#+begin_src ipython
overlaps = df_.groupby('tasks')['overlaps_%s' % epoch].apply(lambda x: np.nanmean(np.stack(x), axis=0))
print(overlaps)
#+end_src

#+RESULTS:
: Series([], Name: overlaps_LD, dtype: object)

#+begin_src ipython
options['bins_CHOICE']
#+end_src

#+RESULTS:
: array([57, 58, 59, 60, 61, 62])
